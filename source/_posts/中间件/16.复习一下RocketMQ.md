---
title: 复习一下RocketMQ
date: 2025-02-05
math: true
mermaid: true
sticky: 0
category: 中间件
tags:
---

## 常用场景

+ 服务解耦：当上游需要将数据同步给多个下游，如果采用回调的方式，耦合程度高
    + 新增下游需要数据：需要上游改代码，新增调用
    + 有的下游不再需要：需要上游改代码，删除调用
    + 有的下游处理失败：需要上游改代码，支持失败重试
    + 采用发布-订阅模式，让下游自行处理失败重试，减少上游代码改动
+ 异步处理：当上游需要将数据同步给多个下游，如果采用回调的方式，处理耗时长
    + 如果是串行回调下游，下游的数量与处理时间是不可控的，连带导致上游接口的耗时不可控
    + 如果是并发调用，只能缓解下游数量与处理时间的不可控，并且还带来了更高的代码复杂度和资源占用
    + 采用发布-订阅模式，让各个下游之间并发消费数据，避免下游处理阻塞上游
+ 削峰填谷
    + 将请求缓冲到MQ里，避免瞬时大流量把服务打挂
    + 依然需要总的消费速度≥生产速度，否则就会导致消息堆积

## 常用MQ对比

| 特性             | ActiveMQ                     | RabbitMQ                                                 | RocketMQ                                                              | Kafka                                                                           |
|----------------|------------------------------|----------------------------------------------------------|-----------------------------------------------------------------------|---------------------------------------------------------------------------------|
| 单机吞吐量          | 万级，吞吐量比RocketMQ和Kafka要低一个数量级 | 万级，吞吐量比RocketMQ和Kafka要低一个数量级                             | 十万级，RocketMQ也是可以支撑高吞吐的一种MQ                                            | 十万级别，Kafka最大优点就是吞吐量大，一般配合大数据类的系统来进行实时数据计算、日志采集等场景                               |
| Topic数量对吞吐量的影响 | -                            | -                                                        | Topic可以达到几百、几千个的级别，吞吐量会有小幅度的下降。这是RocketMQ的一大优势，可在同等数量机器下支撑大量的Topic    | Topic从几十个到几百个的时候，吞吐量会大幅下降。所以在同等机器数量下，Kafka尽量保证Topic数量不要过多。如果支撑大规模Topic需要增加更多的机器 |
| 时效性            | ms级                          | 微秒级，这是rabbitmq的一大特点，延迟是最低的                               | ms级                                                                   | 延迟在ms级以内                                                                        |
| 可用性            | 高，基于主从架构实现可用性                | 高，基于主从架构实现可用性                                            | 非常高，分布式架构                                                             | 非常高，Kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用                                   |
| 消息可靠性          | 有较低的概率丢失数据                   | -                                                        | 经过参数优化配置，可以做到零丢失                                                      | 经过参数配置，消息可以做到零丢失                                                                |
| 功能支持           | MQ领域的功能及其完备                  | 基于erlang开发，所以并发性能极强，性能极好，延时低                             | MQ功能较为完备，分布式扩展性好                                                      | 功能较为简单，主要支持加单MQ功能                                                               |
| 优势             | 非常成熟，功能强大，在业内大量公司和项目中都有应用    | erlang语言开发，性能极好、延时很低，吞吐量万级、MQ功能完备，管理界面非常好，社区活跃；互联网公司使用较多 | 接口简单易用，阿里出品有保障，吞吐量大，分布式扩展方便、社区比较活跃，支持大规模的Topic、支持复杂的业务场景，可以基于源码进行定制开发 | 超高吞吐量，ms级的时延，极高的可用性和可靠性，分布式扩展方便                                                 |
| 劣势             | 偶尔有较低概率丢失消息，社区活跃度不高          | 吞吐量较低，erlang语音开发不容易进行定制开发，集群动态扩展麻烦                       | 接口不是按照标准JMS规范走的，有的系统迁移要修改大量的代码，技术有被抛弃的风险                              | 有可能进行消息的重复消费                                                                    |
| 应用             | 主要用于解耦和异步，较少用在大规模吞吐的场景中      | 都有使用                                                     | 用于大规模吞吐、复杂业务中                                                         | 在大数据的实时计算和日志采集中被大规模使用，是业界的标准                                                    |

## 基本概念

+ 名字服务（Name Server）
    + 负责服务发现
+ 消息（Message）
    + 生成和消费的最小单位
    + 拥有一个唯一的Message ID，也可以携带业务Key。提供通过Message ID和Key查询消息的能力
+ 主题（Topic）
    + 表示同一类消息的集合
    + 每条消息只属于一个Topic，一个Topic有多条消息
+ 标签（Tag）
    + 在同一个Topic下，对消息更细致的划分，实现更好的扩展性
    + 每条消息只属于一个标签，一个标签有多条消息
+ 生产者（Producer）
    + 负责生产消息
    + 多个生产同一类消息（同一个Topic）的生产者，组成一个生产者组
+ 消费者（Consumer）
    + 负责消费消息
    + 多个消费同一类消息（同一个Topic）的消费者，组成一个消费者组
+ 代理服务器（Broker）
    + 负责存储消息
    + 实际部署中对应一个服务器
    + 一个Broker有多个Topic，一个Topic会存储在多个Broker上
+ 分片
    + 某个Topic在某个Broker上的部分称为分片
+ 队列（Queue）
    + 每个分片下会再划分多个队列
    + 每个队列里有多条有序的消息
    + 生产者与消费者实际是往队列里追加和弹出消息
    + 多个队列以提升生产和消费的并发性能，是均衡负载的基本单位
+ 集群消费（Clustering）
    + 每条消息在消费组里只会被一个消费者消费
    + 消息重投时不保证路由回原消费者
    + 每个队列最多分配给一个消费者，每个消费者可以消费多个队列
    + 多个队列将平均分给每个消费者进行消费。如果消费者多于队列，那将有部分消费者无队列可消费
+ 广播消费（Broadcasting）
    + 消费组里每个消费者都会收到全量的消息

todo,补一张十字架示意图

## 消息顺序

+ 普通顺序消息（Normal Ordered Message）
    + 通过Sharding Key将消息hash到某个队列中，队列内部保证有序
    + 消费者在同一个队列里消费到的消息是有序的，不同队列直接的消息则可能无序
    + 可通过增加队列来扩展吞吐量
+ 严格顺序消息（Strictly Ordered Message）
    + 只使用一个队列与一个消费者进行处理，实现了全局有序
    + 吞吐较低，扩展性差

## 消息可靠性

+ 生产者
    + 同步发送：同步等待Broker的接收结果
    + 异步发送：异步接收Broker的接收结果
    + 单向发送：不接收Broker的接收结果
    + retryTimesWhenSendFailed：同步发送失败重试次数，默认=2，因此最多会投3次，每次都选择新的Broker以尽量成功
    + retryTimesWhenSendAsyncFailed：异步发送失败重试次数，但不会选新的Broker
    + 同步刷盘与异步刷盘
+ Broker
    + 可立即恢复服务类，如Broker异常关闭/Broker异常Crash/操作系统Crash/掉电等
        + 能保证不丢或者少丢数据，取决于是同步还是异步刷盘
    + 硬件损坏类，如CPU/内存/硬盘损坏等
        + 该Broker的数据将全部丢失
        + 可通过异步复制/同步双写等方式避免单点故障
+ 消费者
    + 至少一次
        + 消费者消费完成后，再进行ack
        + 保证消息至少被消费一次，但可能会被重复消息
    + 最多一次
        + 消费者先金额ack，在进场消费
        + 保证消息最多给消费一次，但可能会丢

+ 回溯消费
    + 支持按时间维度，精确到毫秒进行回溯，重新消费已经消费完成的消息
+ 事务消息
    + 支持一条类似X/Open XA的分布式事务，以支持本地事务与发送消息操作，实现最终一致
+ 定时消息
    + 支持指定特定的几种时间间隔，让消息延迟被消费
    + 消息会暂存到一个临时的Topic里，不同的时间间隔存在不用队列里，每个队列消息的发送延迟都是相同的，保证相同的发送延迟能被顺序消费
    + Broker会调度消费临时临时Topic，将消息写入真实的Topic
+ 消息重试
    + 如果是消息本身导致消费失败，例如序列化异常，这种立即重试一般都还会是失败
        + 每个消费组会有一个重试队列
        + 跳过该消息，通过重试队列重新消费，每次失败延迟重试的时间间隔
    + 如果是下游服务不可用，例如接口/数据库调用失败，立即重试会增加下游负担
        + 不直接跳过该消息，sleep一小段时间重试
+ 死信队列
    + 当消息初次消费失败，队列会对消息进行重试。如果打到最大重试次数，依然消费失败，消息会进入死信队列

拉取式消费、推动式消费
