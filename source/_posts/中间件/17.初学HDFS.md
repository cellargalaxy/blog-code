## 简介

+ HDFS（Hadoop Distributed File System），是Hadoop的分布式文件系统
+ 起源于2003年谷歌发布的论文The Google File System（GFS），是GFS的简化开源版本
+ HDFS经过了四个大版本更新，目前常用的是2.x与3.x
    + 0.x：最古早的版本
    + 1.x：修复了0.x的一些bug
    + 2.x：引入yarn的许多新特性；支持最多两个NameNode实例（一主一备）
    + 3.x：JAVA最低版本升级为8；支持多个NameNode实例（一主多备）
+ 使用场景：一次写入，多次读取
    + 文件一旦写入完成关闭后，就变成只读了
+ 向HDFS存储文件，客户端负责将文件切割为Block，HDFS以Block为单位存储文件
    + Block的大小默认128M，较大的Block有助于降低寻址开销，也意味着HDFS适合于存储大文件而不是小文件
    + 如果文件大于128M，客户端负责将文件切割为多个不大于128M的Block
    + 如果文件不足128M，则只生成一个Block，一个10M的文件生成的Block也只是10M
+ HDFS的优点
    + 通透性：尽管文件实际是分块存储，但客户端使用就像访问本地磁盘一样
    + 高容错：HDFS的数据会保存多个副本（默认3份），即便部分机器宕机，系统整体也依然高可用且不会导致数据丢失
    + 性价比：能运行在大量廉价机器上
+ HDFS的缺点
    + 不适合低延迟数据访问：数据读写延迟比较高，无法实现毫秒级读写
    + 不适合大量小文件存储：大量小文件意味着大量小Block，会增大NameNode的存储压力
    + 不支持并发写入与随机写入：一个文件同一时间只支持一个线程写入，只支持对文件执行追加操作

## 架构

以Hadoop3.x为例，HDFS架构为主从结构，包括主节点与从节点

+ NameNode（名称节点）
    + 主节点
    + 负责维护文件系统的元数据以及客户端对文件的访问，包括目录树/目录/文件的关系，以及每个文件的Block列表
    + 元数据包含两份数据
        + FsImage：元数据的只读快照，会进行持久化，包含几乎全部元数据，但是数据是落后的
        + Edits：元数据的编辑日志，会进行持久化，NameNode收到元数据的编辑请求，会将编辑情况记录到Edits中
        + NameNode冷启动时，会加载FsImage与Edits到内存中，然后重放Edits，以得到最新的元数据
+ DataNode（数据节点）
    + 从节点
    + 负责处理客户端对Block数据的读写存储
    + 每隔3s会向NameNode定时发送心跳，连续10min都心跳丢失，DataNode会被认为宕机，不再被分配到IO操作
    + 会定时向NameNode上报自己所存储的全部Block信息，让NameNode获取全部Block信息（不会进行持久化），如果有Block损坏及时创建新副本
+ SecondaryNameNode
    + 辅助节点
    + 负责将Edits合并到FsImage，并将新FsImage更新到NameNode中，避免Edits不断增长拖累冷启动时间
+ JournalNode
    + 辅助节点
    + 有多个NameNode实例时，用于维护NameNode实例之间的元数据的一致性

## 读写流程

当客户写入一个文件时

+ 客户端将文件切割为多个Block
+ 客户端请求NameNode，告知每个Block需要三个DataNode来存储3个副本
+ NameNode通过机架感知机制，获取三个DataNode
    + DataNodeA：如果客户端在集群中，则客户端作为第一个DataNode，否则随机取一个DataNode
    + DataNodeB：在DataNodeA以外的机架中，随机取一个DataNode
    + DataNodeC：在DataNodeB机架中，随机取一个DataNode
    + 同一机架共享电源/网线/交换机，不同副本存储在不同机架上避免整个机架宕机
+ NameNode将三个DataNode告知客户端
+ 客户端将Block发送给DataNodeA进行存储
    + DataNodeA将Block同步给DataNodeB
    + DataNodeB将Block同步给DataNodeC
    + 通过机房内部数据同步，减少客户端数据传输
+ DataNode对Block存储完成后，会向NameNode发送结果，以进行下一个Block的存储流程
+ 直到全部Block都存储完成，客户端告知ameNode完成写入

当客户读取一个文件时

+ 客户端将文件名称发送给NameNode
+ NameNode根据文件名称查询到该文件的全部Block，以及这些Block存储在哪些DataNode中
+ 将Block与DataNode信息返回给客户端
+ 客户端直接访问DataNode，读取文件

## 高可用

+ 3.x支持在一个集群上，部署多个NameNode实例
+ 任意时间点只有一个NameNode是Active状态，其余均为Standby状态
+ Active负责处理全部请求，Standby会同步Active的元数据，并且进行合并
    + Standby提供快速恢复能力
    + 不能再使用SecondaryNameNode
+ FsImage与Edits合并
    + 每隔一段时间，SecondaryNameNode会要求NameNode切换新的Edits文件
    + SecondaryNameNode将NameNode的FsImage与Edits拉回本地内存，进行合并操作
    + 将合并后的FsImage同步回给NameNode
    + NameNode使用新替换旧FsImage，并且废弃旧Edits
+ Active与Standby的元数据一致性
    + 元数据有两类，静态的是FsImage与Edits，动态的是Block与DataNode关系
    + FsImage只读，因此只需要保证Edits的事务性同步，通过JournalNode实现
    + DataNode会向全部NameNode实例，上报自己的Block，因此每个NameNode的动态数据是时刻同步的
+ 当Active收到元数据的编辑请求时
    + Active将Edits持久化到多数JournalNode里
    + Active更新自己内存中的Edits
    + 返回客户端成功
    + Active异步持久化自己的Edits
    + Standby通过JournalNode获取到Active的Edits
    + 一旦Active宕机，Standby需要保证从JournalNode中拉取到最新的Edits，然后进行选主
+ 选主
    + NameNode启动的时候会向zookeeper注册一个临时节点，如果Active挂了，Active的临时节点也会消失
    + zookeeper会有个监视器监视到，会将原NameNode置为Standby，选择另外一个NameNode置为Active

## 高扩展

+ 通过HDFS Federation，使每个NameNode实例只负责一部分的元数据
+ 避免元数据大小，受限于NameNode的内存大小
+ 提高吞吐
+ 不同业务数据交由不同的NameNode与DataNode管理，减少业务间的影响

## 参考资料

+ https://zhuanlan.zhihu.com/p/459921566
+ https://www.hangge.com/blog/cache/detail_3430.html
+ https://www.dingyuqi.com/article/pprd8n4y/
+ https://www.cnblogs.com/liangzilx/p/14851367.html
+ http://www.uml.org.cn/bigdata/201909273.asp
+ https://cloud.tencent.com/developer/article/1043733
+ https://chat.deepseek.com/a/chat/s/61caa17e-c5b4-4d4e-bf16-f5f45b86d14c