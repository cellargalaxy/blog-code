# 总结
+ 预处理：排序
+ 数据结构：hash
+ 下标确定：二分法
+ 目标值/极值-下标/区间：积分法，指针夹逼
+ 动态规划：临时变量
+ 查找循环：快慢指针
+ 回溯查找：hash回溯法、指针回溯法

+ 积分法：数组与结果关系表现为无向性
  - max，sum，左右指针都在左边
  - 右指针扫描，计算sum，记录max
  - 确定拖累极值**状态**，一直重置左指针与sum

+ 指针夹逼：数组与结果关系表现为有向性
  - max，sum，左右指针在左右
  - 计算sum，记录max，夹逼劣指针



# 题目
+ ✔[1]两数之和：一般不会靠节省内存，多是考时间复杂度。想办法用上hashMap或者hashSet就能自动降低时间复杂度。

+ ✔[14]最长公共前缀：递归和二分法也能降低时间复杂度。递归适用于重复相同的操作，因此变成数组求和数组求公因数也是一样的。
  二分法感觉这里用的比较巧妙，对最短字符串进行二分。是不是确定下标位类型的都能用二分？

+ ✔[26]删除排序数组中的重复项：**指针回溯法**。我一开始想到的是用个二进制数字标记那些数字已经出现过，最后数一下出现过的数字的数量和值就好。


+ ✔[35]搜索插入位置：又是一个用二分法确定下标位的类型

+ ✔[53]最大子序和：**积分法**。这个有点有趣，可以把这个问题泛化为有一个函数f(x)，求区间`[a,b]`使得`∫(b,a)f(x)`最大，其中`a>A,b<B`。
  方法就是将x从左往右移动计算sum，记录出现过的max，但如果sum<0则将a重置为当前x，sum重置为0。使得尽可能将负的丢掉。
  例如`[-2,1,-3,4,-1,2,1,-5,4]`->`[-2|1 -2|4  3 5 6  1 5]`。其中`|`为重置的地方。

+ [69]x的平方根：计算平方根可以用二分法(好像高中?有介绍过,不过我忘了)，用于在一定可比较范围内求一值

+ ✔[70]爬楼梯：**动态规划**。爬楼梯这个递归我想错地方了。连续的依赖性重复步骤，都可以类推为斐波那契数，也是动态规划，即第n步依赖于前几步的结果。
  根据实际问题，这个前几步的结果的求解可以用递归，也可以只用几个中间值临时保存。

+ [108]将有序数组转换为二叉搜索树：奇怪的题，取数组中间为根节点，左边的都是左节点，右边的都是右节点就满足要求了……？……。
  - 知识点：
  - 有序二叉树的中根遍历是有序的
  - 可以把`取数组中间为根节点，左边的都是左子树，右边的都是右子树`这个操作递归，能使得数平衡且最矮。

+ ✔[111]二叉树的最小深度：扫描有两种，一直深度扫，根据全局最小深度觉得要不要继续往下扫，以及更新全局最小深度。
  二是广度扫，扫到某一行有个叶子节点结束。

+ ✔[121]买卖股票的最佳时机：**积分法**。跟最大子序和类似。

+ [136]只出现一次的数字：本来我想的是用个二进制标记出现过的数组，出现第二次的时候把1设回0，最后是1的那个数字出现了一次。
  但是发现`^`这个位运算是自可逆的，即`n=n^a^a`，且`0^a=a`，所以搞个0跟全部的数`^`一下，最后就剩下只出现过一次的那个数字。

+ ✔[141]环形链表：**快慢指针**。有趣的题，用两个引用，第一个引用每次走一步，第二个引用走两步，如果循环，那这两个引用肯定会相等。快慢指针

+ ✔[160]相交链表：老题了，以前阿里面试面过。对齐两个链表的尾，长的先跑，跑到短的头，再一起向前。

+ [167]两数之和 II - 输入有序数组：**指针夹逼**。在两数之和I里是用map解决的，如果要空间O(1)，有序数组，我本来想到的是用二分法替代map。
  但如果用两个下标，放在数组头和数组尾，两数之和大了，大下标往左移，直到和等于目标值，结束。
  或者和小于目标值，小下标往右移一位，大下标在原地继续往左移，直到两下标相遇。

+ ✔[169]多数元素：一条奇妙的题
  - 解法一：最菜的hash表计数
  - 解法二：将数值排序，中间的那个数就是众数（依赖于众数有过半数）
  - 解法三：数值左边的众数与右边的众数的结果就是全局众数，进行递归（依赖于众数有过半数）
  - 解法四：假设第一个数为众数，遍历数值，遇到众数sum+1，非众数sum-1，sum==0时更换众数为当前数。总感觉与最大子序和、买卖股票类似。

+ ✔[172]阶乘后的零：多少个0有多少个10(2*5)，2数量>5数量，所以等于`n/5 + n/25 + n/125 ……`。
  但是`5->25->125`这样下去容易超过int，所以应该是将n/5替代`5->25->125`。

+ ✔[189]旋转数组：有点神奇
  - 将整个数组挪三次
  - 将数字一步到位放到对应位置，用两个下标和临时变量。麻烦的是如果`k%n==0`会下标循环。
    没能完全想明白在这种情况下，嵌多一层循环判断下标循环，之后开始的下标比上一次+1就好。
  - 将整个数组翻转，之后分别将数组`[:k-1]`和`[k:]`的内部再翻转，这个有点巧妙，展示没想到其他拓展

+ ✔[198]打家劫舍：**动态规划**。全部的(暂时没想到反例)第k步的决策取决与前n(n有限)步的结果，则这种动态规划都可以通过设备n个临时变量+一次遍历+保存决策过程中的目标值解决。

+ ✔[202]快乐数：**快慢指针**。貌似全部的查找循环都可以用快慢指针？

+ ✔[204]计数质数：用了一个bool数组保存0-n的数是不是素数，默认全部都是，循环1的i从2(确实是素数)开始，循环2修改bool数组，i的倍数都不是素数。
  循环1`(2;i*i<n;i++)`，循环2`(i*i;j<n;j+=i)`

---

+ ✔[3]无重复字符的最长子串：**积分法+hash回溯法**。解法是用个map保存字符与出现的位置，当有重复的时候，回去看哪个位置出现过，那就在那个位置里重新开始遍历。

+ ✔[6]Z 字形变换：可以通过遍历字符串的时间，记录每一行的的字符的下标

+ ✔[8]字符串转换整数 (atoi)：处理过程是有限状态，每个状态的处理也是有限，可以画个表

+ ✔[15]三数之和：**指针夹逼**。求目标值，对数组排序后用夹逼法。由于是三下标，所以必定是两层循环了。中指针遍历，当中指针为某一值时，左右指针夹逼。

+ ✔[31]下一个排列：从右往左找到第一个下跌的数组，在这个数组右边找比这个数组大的最小数，交互这两个数，升序下跌数的右边全部的数

+ ✔[36]有效的数独：**hash回溯法**。遍历时检查现在与以前关系，可以用hash。

+ ✔[55]跳跃游戏：遍历数组，更新能走到的最远的地方，如果遍历时发现所在地方比最远地方更远，则gg，否则就这样一直走能走到最后