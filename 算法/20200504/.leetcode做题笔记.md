# 总结
+ ✔[1]两数之和：一般不会靠节省内存，多是考时间复杂度。想办法用上hashMap或者hashSet就能自动降低时间复杂度。

+ ✔[14]最长公共前缀：递归和二分法也能降低时间复杂度。递归适用于重复相同的操作，因此变成数组求和数组求公因数也是一样的。
  二分法感觉这里用的比较巧妙，对最短字符串进行二分。是不是确定下标位类型的都能用二分？

+ ✔[26]删除排序数组中的重复项：我一开始想到的是用个二进制数字标记那些数字已经出现过，最后数一下出现过的数字的数量和值就好。
    看了答案之后可以用两个指针解决，但就没看出通用性。

+ ✔[35]搜索插入位置：又是一个用二分法确定下标位的类型

+ ✔[53]最大子序和：这个有点有趣，可以把这个问题泛化为有一个函数f(x)，求区间`[a,b]`使得`∫(b,a)f(x)`最大，其中`a>A,b<B`。
    方法就是将x从左往右移动计算sum，记录出现过的max，但如果sum<0则将a重置为当前x，sum重置为0。使得尽可能将负的丢掉。
    例如`[-2,1,-3,4,-1,2,1,-5,4]`->`[-2|1 -2|4  3 5 6  1 5]`。其中`|`为重置的地方。

+ [69]x的平方根：计算平方根可以用二分法(好像高中?有介绍过,不过我忘了)，用于在一定可比较范围内求一值

+ ✔[70]爬楼梯：爬楼梯这个递归我想错地方了。连续的依赖性重复步骤，都可以类推为斐波那契数，也是动态规划，即第n步依赖于前几步的结果。
    根据实际问题，这个前几步的结果的求解可以用递归，也可以只用几个中间值临时保存。

+ [108]将有序数组转换为二叉搜索树：奇怪的题，取数组中间为根节点，左边的都是左**节点**，右边的都是右**节点**就满足要求了……？……。
  - 知识点：
  - 有序二叉树的中根遍历是有序的
  - 可以把`取数组中间为根节点，左边的都是左子树，右边的都是右子树`这个操作递归，能使得数平衡切最矮。

+ ✔[111]二叉树的最小深度：扫描有两种，一直深度扫，根据全局最小深度觉得要不要继续往下扫，以及更新全局最小深度。二是广度扫，扫到某一行有个叶子节点结束。

+ ✔[121]买卖股票的最佳时机：跟最大子序和类似

+ [136]只出现一次的数字：本来我想的是用个二进制标记出现过的数组，出现第二次的时候把1设回0，最后是1的那个数字出现了一次。
    但是发现`^`这个位运算是自可逆的，即`n=n^a^a`，且`0^a=a`，所以搞个0跟全部的数`^`一下，最后就剩下只出现过一次的那个数字。

+ ✔[141]环形链表：有趣的题，用两个引用，第一个引用每次走一步，第二个引用走两步，如果循环，那这两个引用肯定会相等

+ ✔[160]相交链表：老题了，以前阿里面试面过。对齐两个链表的尾，长的先跑，跑到短的头，再一起向前。

+ [167]两数之和 II - 输入有序数组：在两数之和I里是用map解决的，如果要空间O(1)，有序数组，我本来想到的是用二分法替代map。
    但如果用两个下标，放在数组头和数组尾，两数之和大了，大下标往左移，直到和等于目标值，结束。或者和小于目标值，小下标往右移一位，大下标在原地继续往左移，直到两下标相遇。

+ ✔[169]多数元素：一条奇妙的题
  - 解法一：最菜的hash表计数
  - 解法二：将数值排序，中间的那个数就是众数（依赖于众数有过半数）
  - 解法三：数值左边的众数与右边的众数的结果就是全局众数，进行递归（依赖于众数有过半数）
  - 解法四：假设第一个数为众数，遍历数值，遇到众数sum+1，非众数sum-1，sum==0时更换众数为当前数。总感觉与最大子序和、买卖股票类似。

+ ✔[172]阶乘后的零：多少个0有多少个10(2*5)，2数量>5数量，所以等于`n/5 + n/25 + n/125 ……`。但是`5->25->125`这样下去容易超过int，所以应该是将n/5替代`5->25->125`。

+ [175]组合两个表
