__NUXT_JSONP__("/view/java/20200515/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai){return {data:[{siteConfig:{siteName:J,siteHost:"https:\u002F\u002Fcellargalaxy.github.io",basePath:"\u002Fblog-code\u002F",navs:[{text:"文章",url:"\u002Fblog-code\u002Fpage\u002F1\u002F"},{text:"归档",url:"\u002Fblog-code\u002Farchive\u002F0\u002F"},{text:"画画",url:"\u002Fblog-code\u002Fhtml\u002Fhua.html"},{text:"开源",url:"\u002Fblog-code\u002Fhttps:\u002Fgithub.com\u002Fcellargalaxy\u002Fblog-vue"}],pageSize:10,urlReplace:{"^/file/blog/code":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode"},backgroundImage:{duration:K,fade:1000,images:[{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FcofTzDQXitjeVZ6.jpg",description:L,type:o},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FsfaRJ2lVeM3NDbE.jpg",description:L,type:o},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F26\u002FKybiTdftam5Su7x.jpg",description:"青春猪头-双葉理央",type:o},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F09\u002F08\u002FxdX73nfs24qgOYk.jpg",description:"京吹-明日香,久美子",type:o},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F14\u002FMAiruNcEFW2HYtg.jpg",description:"终将成为你-七海灯子,小糸侑",type:o},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F05\u002FEojdAxTDJsFpbPw.jpg",description:"玉子市场-北白川玉子",type:o},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F31\u002FAXxwJDRS9fmN2uU.jpg",description:"fate_hf-弓道馆",type:o},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F01\u002FaHhVObpJus6dnM4.jpg",description:"fate_hf-樱花树",type:o}]}},homeConfig:{brandInterval:K,brands:[{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F21\u002FmMEAnwY5XPC2pFb.jpg",title:"日常",texts:["我们所度过的每个平凡的日常，也许就是连续不断发生的奇迹。","日々、私たちが過ごしている日常は、実は奇跡の連続なのかもしれない。"]},{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F04\u002F19\u002FH1MmXb9xPcYEhT2.jpg",title:"昨日之歌",texts:["时间梭梭箭如飞，人道漫漫步蹒跚","人間そんな変わるもんじゃないのに、月日ばっかどんどん過ぎて"]}],navs:[{text:"Github",url:"https:\u002F\u002Fgithub.com\u002Fcellargalaxy\u002F"}]},pageFootConfig:{lines:[[{text:"Copyright © 2017-? ."},{text:"备案？不存在的"},{text:"Powered by Nuxt.js & Github"}]]},buildTime:new Date(1659171920105),siteName:J,file:{slug:M,description:A,createdAt:N,updatedAt:N,toc:[{id:v,depth:l,text:v},{id:w,depth:l,text:w},{id:x,depth:l,text:x},{id:y,depth:l,text:y},{id:O,depth:l,text:B},{id:P,depth:l,text:Q},{id:R,depth:l,text:C},{id:S,depth:l,text:D},{id:T,depth:l,text:U},{id:V,depth:E,text:W},{id:X,depth:E,text:Y},{id:Z,depth:E,text:_}],body:{type:$,children:[{type:a,value:c},{type:b,tag:F,props:{id:aa},children:[{type:b,tag:f,props:{href:"#%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E6%96%AD",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:aa}]},{type:a,value:c},{type:b,tag:p,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"引用计数：一个对象被引用了，计数+1，否则就-1，如果计数为0，意味着没有被引用可以回收。\n但是无法解决对象相互循环引用的问题。"},{type:b,tag:"del",props:{},children:[{type:a,value:"用快慢指针不就好了吗（笑"}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"可达性分析：从GC Roots开始向下搜索引用对象，如果一个对象没有被搜索到的话，为不可达对象，意味着没有被引用可以回收。\nGC Roots包括：\n"},{type:b,tag:p,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"方法区的常量\u002F静态对象"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"虚拟机栈的对象"}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:F,props:{id:ab},children:[{type:b,tag:f,props:{href:"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:ab}]},{type:a,value:c},{type:b,tag:m,props:{id:v},children:[{type:b,tag:f,props:{href:"#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:v}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:ac},{type:b,tag:ad,props:{},children:[{type:a,value:"死亡"}]},{type:a,value:"的对象，标记完成后回收死亡对象的空间。\n会产生空间碎片，如果要分配大对象而又没有足够大的空间，就又会触发GC以期清除出足够大的空间。"}]},{type:a,value:c},{type:b,tag:m,props:{id:w},children:[{type:b,tag:f,props:{href:"#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:ac},{type:b,tag:ad,props:{},children:[{type:a,value:"存活"}]},{type:a,value:"的对象，然后将存活对象移到内存的一端，清理边界以外的内存。\n能整理出大片的连续空间。如果对象多是长命不动的，需要被整理的对象就会相对较少，因此适用于老年代。"}]},{type:a,value:c},{type:b,tag:m,props:{id:x},children:[{type:b,tag:f,props:{href:"#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:x}]},{type:a,value:c},{type:b,tag:p,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"将内存划为大小一样的两半。新对象分配在其中一半，需要GC时，把存活对象复制到另外一半内存，清空本来的一半内存。\n虽然内存划一半能确保存活对象都能放下，但是就是浪费了一半的内存。由于需要将存活对象来回复制，所以适用于新生代。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"升级版复制算法是将内存划分为两个幸存区和一个eden区，比例1:1:8。\n新对象在eden区分配，需要GC时，把存活对象复制到其中一个幸存区，清空eden区和另一个幸存区。\n由于幸存区未必放得下全部存活对象，因此会使用老年代的内存来担保。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:F,props:{id:ae},children:[{type:b,tag:f,props:{href:"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:ae}]},{type:a,value:c},{type:b,tag:m,props:{id:y},children:[{type:b,tag:f,props:{href:"#%E6%A6%82%E5%BF%B5",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:y}]},{type:a,value:c},{type:b,tag:p,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"并行（Parallel）：多条垃圾收集线程并行，用户线程依然STW"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"并发（Concurrent）：用户线程与垃圾收集线程同时执行（不一定在并发，要看CPU调度，反正用户线程没被STW）"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"吞吐量：用户代码时间 \u002F（用户代码时间 + 垃圾收集时间），所以看重总体占比，而非每次垃圾收集时间长短"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"新生代GC（Minor GC）：新生代垃圾收集，比较频繁，速度较快"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"老年代GC（Major GC \u002F Full GC）：Full GC指新生代和老年代都GC，但很多时候老年代的GC是由新生代GC触发的"}]},{type:a,value:c}]},{type:a,value:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{type:b,tag:"table",props:{},children:[{type:b,tag:"thead",props:{},children:[{type:b,tag:z,props:{},children:[{type:b,tag:G,props:{},children:[]},{type:b,tag:G,props:{},children:[{type:a,value:"新生代"}]},{type:b,tag:G,props:{},children:[{type:a,value:"老年代"}]}]}]},{type:b,tag:"tbody",props:{},children:[{type:b,tag:z,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"串行回收"}]},{type:b,tag:n,props:{},children:[{type:a,value:"Serial"}]},{type:b,tag:n,props:{},children:[{type:a,value:"Serial Old"}]}]},{type:b,tag:z,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"并行回收"}]},{type:b,tag:n,props:{},children:[{type:a,value:"ParNew,Parallel Scavenge"}]},{type:b,tag:n,props:{},children:[{type:a,value:"Parallel Old"}]}]},{type:b,tag:z,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:"并发回收"}]},{type:b,tag:n,props:{},children:[{type:a,value:"G1"}]},{type:b,tag:n,props:{},children:[{type:a,value:"CMS,G1"}]}]}]}]},{type:a,value:c},{type:b,tag:m,props:{id:O},children:[{type:b,tag:f,props:{href:"#serial%E4%B8%8Eserial-old",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"STW，单线程，新生代使用复制算法，老年代使用标记-整理算法。\n适用于桌面应用，内存不大，STW时间短。单核服务器，单线程效率高。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:q,props:{alt:B,"data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200515\u002Fpic.yupoo.com-crowhawk-6b90388c-6c281cf0.png.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:m,props:{id:P},children:[{type:b,tag:f,props:{href:"#parnew",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:Q}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"ParNew是Serial的多线程版本，新生代收集器。\n在Server模式下，是除了Serial，唯一能和CMS配合的收集器。"}]},{type:a,value:c},{type:b,tag:m,props:{id:R},children:[{type:b,tag:f,props:{href:"#parallel-scavenge%E4%B8%8Eparallel-old",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:C}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"STW，多线程，新生代使用复制算法，老年代使用标记-整理算法。\n关注吞吐量，适合于后台交互不多的服务。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:q,props:{alt:C,"data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200515\u002Fpic.yupoo.com-crowhawk-9a6b1249-b1800d45.png.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:m,props:{id:S},children:[{type:b,tag:f,props:{href:"#cms%E6%94%B6%E9%9B%86%E5%99%A8",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:D}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"CMS（Concurrent Mark Sweep）是老年代收集器，使用标记-清除算法。\n以最短停顿时间为目标，所以适用交互比较多的Server。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"CMS收集器工作分为四个步骤："}]},{type:a,value:c},{type:b,tag:H,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:af}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:ag}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"重新标记：STW，修正在并发标记期间，用户线程继续运行所变动的对象的标记"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"并发清除：使用标记-清除算法进行清除"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:q,props:{alt:D,"data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200515\u002Fpic.yupoo.com-crowhawk-fffcf9a2-f60599b2.png.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"耗时主要在并发标记和并发清除，有点低停顿，并发收集。缺点是："}]},{type:a,value:c},{type:b,tag:H,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"使用标记-清除算法会导致内存碎片。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"不过可以通过虚拟机参数配置在Full GC之前进行碎片整理，也可以设置多少次Full GC进行一次碎片整理。\n2. 并发标记期间无法标记用户线程产生的新垃圾，需要下次GC再清理。\n并且不能等到内存满了再GC，不然在GC时就没有新内存给用户线程申请了。\n如果真的在GC时没有内存了，会使用Serial Old做备案。\n3. 并发能力依赖于CPU资源，如果CPU紧张，性能会比较差。"}]},{type:a,value:c},{type:b,tag:m,props:{id:T},children:[{type:b,tag:f,props:{href:"#g1%E6%94%B6%E9%9B%86%E5%99%A8",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:U}]},{type:a,value:c},{type:b,tag:I,props:{id:V},children:[{type:b,tag:f,props:{href:"#g1%E5%86%85%E5%AD%98%E5%88%92%E5%88%86",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:W}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"G1将内存划分为多个等大小的区域（Region），区域最小1M，最大32M，需是2的幂次方，默认会把堆进行2048等分。\n这些区域可能是Eden，Survivor、Humongous区和未使用区域。逻辑上映射为eden区、幸存区、老年代。\n其中，Humongous用于存放大于50%区域大小的对象。如果一个H区还装不下，G1回去寻找连续的H区，为此可能会使用Full GC。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:q,props:{alt:A,"data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200515\u002Fpic4.zhimg.com-80-v2-8f3ff3c893b1460062885e5122adf4bb_720w.jpg.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:I,props:{id:X},children:[{type:b,tag:f,props:{href:"#remembered-set",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:Y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"由于G1将堆划分为多个区域，对象可能会引用多个其他区域的对象，这导致在可达性分析时需要扫描整个堆。\n为此G1在每个区域里维护了一个Remembered Set，当发现对引用进行写操作时，虚拟机会加一个写屏障，在写之前检查新写入的引用的对象，是否有引用其他区域的对象。\n如果有则记录在Remembered Set里。这样子在可达性分析时只需要在Remembered Set上分析即可，避免对全堆扫描。"}]},{type:a,value:c},{type:b,tag:I,props:{id:Z},children:[{type:b,tag:f,props:{href:"#g1%E5%9B%9E%E6%94%B6%E6%AD%A5%E9%AA%A4",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:_}]},{type:a,value:c},{type:b,tag:H,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:af}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:ag}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"最终标记：STW，修正在并发标记期间，用户线程继续运行所变动的对象的标记。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"虚拟机会将这段时间里对象的变化记录在Remembered Set Logs里，此时会把Remembered Set Logs的变化合并到Remembered Set中\n4. 筛选回收：STW(老年代使用标记-整理算法)，对各个区域的回收价值和成本进行排序，根据用户指定的停顿时间指定回收计划。\n通过控制回收的区域数量来控制停顿时间。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:q,props:{alt:A,"data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200515\u002Fpic.yupoo.com-crowhawk-53b7a589-0bce1667.png.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:p,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"G1使用复制算法和标记-整理算法，不会产生内存碎片。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"G1依然有分代，但是通过把内存划分为多个区域的设计，使得G1能同时管理整个堆。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"G1支持并发回收，并且通过并行回收，利用多核CPU来缩短停顿时间。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"G1通过维护每个区域的回收空间大小与回收成本的经验值，使G1能在有限时间里达到最大的回收效率。（G1，Garbage-First名字的由来）"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"G1适用于多CPU，大内存(\u003E=4G)的服务端上。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"参考文章"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FolNXcRAT3PTK-hV_ehtmtw",rel:[r,s,t],target:u},children:[{type:a,value:"jvm系列(三):GC算法 垃圾收集器"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fcrowhawk.github.io\u002F2017\u002F08\u002F15\u002Fjvm_3\u002F",rel:[r,s,t],target:u},children:[{type:a,value:"深入理解JVM(3)——7种垃圾收集器"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fjuejin.im\u002Fpost\u002F5bade237e51d450ea401fd71",rel:[r,s,t],target:u},children:[{type:a,value:"一文了解JVM全部垃圾回收器，从Serial到ZGC"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fwww.cnblogs.com\u002Fbigben0123\u002Fp\u002F11365070.html",rel:[r,s,t],target:u},children:[{type:a,value:"7种 JVM 垃圾收集器特点、优劣势及使用场景(多图)"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F59861022",rel:[r,s,t],target:u},children:[{type:a,value:"深入剖析JVM：G1收集器+回收流程+推荐用例"}]}]}]},excerpt:{type:$,children:[]},dir:ah,path:"\u002Fjava\u002F20200515\u002F垃圾收集算法与垃圾收集器",extension:".md",title:M,url:"\u002Fblog-code\u002Fview\u002Fjava\u002F20200515\u002F垃圾收集算法与垃圾收集器\u002F",createAt:new Date(1589500800000),updateAt:new Date(1589500800000),attributes:[{name:"createAt",value:ai},{name:"updateAt",value:ai},{name:"sort",value:ah,url:"\u002Fblog-code\u002Fpage\u002Fjava\u002F20200515\u002F1\u002F"}]}}],fetch:{},mutations:void 0}}("text","element","\n","p","li","a","true",-1,"span","icon","icon-link",2,"h2","td","wide","ul","img","nofollow","noopener","noreferrer","_blank","标记-清除算法","标记-整理算法","复制算法","概念","tr","","Serial与Serial Old","Parallel Scavenge与Parallel Old","CMS收集器",3,"h1","th","ol","h3","无名の窝",10000,"青春猪头-牧之原翔子-江之岛","垃圾收集算法与垃圾收集器","2020-05-15T00:00:00.000Z","serial与serial-old","parnew","ParNew","parallel-scavenge与parallel-old","cms收集器","g1收集器","G1收集器","g1内存划分","G1内存划分","remembered-set","Remembered Set","g1回收步骤","G1回收步骤","root","对象存活判断","垃圾收集算法","先标记","strong","垃圾收集器","初始标记：STW，只是标记一下GC Roots能直接关联到的对象，速度很快","并发标记：进行可达性分析，耗时长","\u002Fjava\u002F20200515","2020-05-15")));