__NUXT_JSONP__("/view/中间件/20200603/Redis总结", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_){return {data:[{siteConfig:{siteName:F,siteHost:"https:\u002F\u002Fcellargalaxy.github.io",basePath:"\u002Fblog-code\u002F",navs:[{text:"文章",url:"\u002Fblog-code\u002Fpage\u002F1\u002F"},{text:"归档",url:"\u002Fblog-code\u002Farchive\u002F0\u002F"},{text:"画画",url:"\u002Fblog-code\u002Fhtml\u002Fhua.html"},{text:"开源",url:"\u002Fblog-code\u002Fhttps:\u002Fgithub.com\u002Fcellargalaxy\u002Fblog-vue"}],pageSize:10,urlReplace:{"^/file/blog/code":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode"},backgroundImage:{duration:G,fade:1000,images:[{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FcofTzDQXitjeVZ6.jpg",description:H,type:v},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FsfaRJ2lVeM3NDbE.jpg",description:H,type:v},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F26\u002FKybiTdftam5Su7x.jpg",description:"青春猪头-双葉理央",type:v},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F09\u002F08\u002FxdX73nfs24qgOYk.jpg",description:"京吹-明日香,久美子",type:v},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F14\u002FMAiruNcEFW2HYtg.jpg",description:"终将成为你-七海灯子,小糸侑",type:v},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F05\u002FEojdAxTDJsFpbPw.jpg",description:"玉子市场-北白川玉子",type:v},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F31\u002FAXxwJDRS9fmN2uU.jpg",description:"fate_hf-弓道馆",type:v},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F01\u002FaHhVObpJus6dnM4.jpg",description:"fate_hf-樱花树",type:v}]}},homeConfig:{brandInterval:G,brands:[{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F21\u002FmMEAnwY5XPC2pFb.jpg",title:"日常",texts:["我们所度过的每个平凡的日常，也许就是连续不断发生的奇迹。","日々、私たちが過ごしている日常は、実は奇跡の連続なのかもしれない。"]},{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F04\u002F19\u002FH1MmXb9xPcYEhT2.jpg",title:"昨日之歌",texts:["时间梭梭箭如飞，人道漫漫步蹒跚","人間そんな変わるもんじゃないのに、月日ばっかどんどん過ぎて"]}],navs:[{text:"Github",url:"https:\u002F\u002Fgithub.com\u002Fcellargalaxy\u002F"}]},pageFootConfig:{lines:[[{text:"Copyright © 2017-? ."},{text:"备案？不存在的"},{text:"Powered by Nuxt.js & Github"}]]},buildTime:new Date(1684674697249),siteName:F,file:{slug:I,description:w,createdAt:J,updatedAt:J,toc:[{id:y,depth:o,text:y},{id:z,depth:o,text:z},{id:x,depth:o,text:x},{id:A,depth:o,text:A},{id:K,depth:o,text:L},{id:M,depth:o,text:N},{id:O,depth:o,text:P},{id:B,depth:o,text:B},{id:C,depth:o,text:C}],body:{type:Q,children:[{type:a,value:c},{type:b,tag:n,props:{id:R},children:[{type:b,tag:g,props:{href:"#%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:R}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"高性能：查询速度快"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"高并发：支持并发高"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:n,props:{id:"redis模型"},children:[{type:b,tag:g,props:{href:"#redis%E6%A8%A1%E5%9E%8B",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:"Redis模型"}]},{type:a,value:c},{type:b,tag:"ol",props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"先注册server socket的可读事件。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"当有客户端请求接入，IO多路复用就会把server socket放进队列里。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"然后事件分派器会把server socket分派到应答处理器里，获得与客户端连接的socket，将socket的可读事件与命令请求处理器关联。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"当客户端发出命令请求，socket有可读事件，事件分派器就会把socket分派到命令请求处理器。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"执行命令完成后，会把socket的可写事件与命令回复处理器关联。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"等到客户端可写，有可写事件，又会把socket放进队列里，分派到命令回复处理器回复命令执行结果。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"使用纯内存，速度快"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"使用IO多路复用"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"命令执行为单线程，避免上写文切换"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"redis的单线程只是命令执行使用单线程，处理网络IO和后台删除过期key是使用多线程处理的。\nredis一开始使用单线程处理是因为IO多路复用，加上操作都是纯内存操作，处理速度快，单个线程就可以处理大量的连接。\n但是其中有很多的cpu时间是用来进行网络IO的，所以把网络IO和其他后台任务用多线程提高处理速度，命令执行依然用单线程。"}]},{type:a,value:c},{type:b,tag:n,props:{id:"redis数据类型与使用场景"},children:[{type:b,tag:g,props:{href:"#redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:"Redis数据类型与使用场景"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"string\n"},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"分布式锁"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"自增计数器、秒杀、访问频率"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"分布式唯一ID：时间戳+自增值"}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"list\n"},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"消息队列：往左边加数据"},{type:b,tag:e,props:{},children:[{type:a,value:"lpush key value"}]},{type:a,value:"。往右边取数据，没有数据则阻塞到超时(如10s)"},{type:b,tag:e,props:{},children:[{type:a,value:"brpop key value 10"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"列表最新消息：消息从左边插入，查左边前十个消息"},{type:b,tag:e,props:{},children:[{type:a,value:"lrange key 0 9"}]}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:x}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"set\n"},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"抽奖活动：所有抽奖用户"},{type:b,tag:e,props:{},children:[{type:a,value:"smembers key"}]},{type:a,value:"，随机抽N个用户并删除"},{type:b,tag:e,props:{},children:[{type:a,value:"spop key N"}]},{type:a,value:"，随机抽N个用户不删除"},{type:b,tag:e,props:{},children:[{type:a,value:"srandmember key N"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"点赞、签到、like功能"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"共同关注、可能认识的人：交并差集"}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"sorted set\n"},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"排行榜"}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:p,props:{id:y},children:[{type:b,tag:g,props:{href:"#string",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:y}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"redis的字符串没有使用c自带的字符串，而是重新实现了一个简单动态字符串（simple dynamic string，SDS）。\n但SDS除了扩容还会惰性缩容，缩容后会把空间腾出来，以备以后扩容，并不会重新分配内存。\n扩容规则是小于1M则比len*2大的2^n，大于1M的则len+1M。\n有点像StringBuilder，StringBuilder内部也有个"},{type:b,tag:e,props:{},children:[{type:a,value:"char[]"}]},{type:a,value:"可以扩容追加内容。"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{},children:[{type:a,value:"buf"}]},{type:a,value:"：二进制数组，保存数据，休止符为"},{type:b,tag:e,props:{},children:[{type:a,value:"'\\0'"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{},children:[{type:a,value:"len"}]},{type:a,value:"：字符串长度"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{},children:[{type:a,value:"alloc"}]},{type:a,value:"：标头和休止符的长度"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{},children:[{type:a,value:"flags"}]},{type:a,value:"：字节属性，是sdshdr8还是sdshdr16"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:D,props:{alt:w,"data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200603\u002Fuser-gold-cdn.xitu.io-2019-9-12-16d245812d1e41c5.jpg.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:p,props:{id:z},children:[{type:b,tag:g,props:{href:"#list",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:z}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"redis的链表就是个标准的双向链表，list对象有头尾节点和节点数量"}]},{type:a,value:c},{type:b,tag:p,props:{id:x},children:[{type:b,tag:g,props:{href:"#hash",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:x}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"redis的hash也与java的类似，hash桶的个数是2^n，每个桶里是个链表。\n但实际hash桶的数组有两个，在ht这个数组里。\n"},{type:b,tag:e,props:{},children:[{type:a,value:E}]},{type:a,value:"和"},{type:b,tag:e,props:{},children:[{type:a,value:q}]},{type:a,value:"是一样的，不过"},{type:b,tag:e,props:{},children:[{type:a,value:q}]},{type:a,value:"是在rehash的时候使用。\n扩容rehash条件是负载因子("},{type:b,tag:e,props:{},children:[{type:a,value:"ht[0].used \u002F ht[0].size"}]},{type:a,value:")大于1，缩容rehash条件是负载因子小于0.1。\n扩容是创建一个大于"},{type:b,tag:e,props:{},children:[{type:a,value:"ht[0].used*2"}]},{type:a,value:S},{type:b,tag:e,props:{},children:[{type:a,value:q}]},{type:a,value:"。\n缩容则是创建一个大于"},{type:b,tag:e,props:{},children:[{type:a,value:"ht[0].used"}]},{type:a,value:S},{type:b,tag:e,props:{},children:[{type:a,value:q}]},{type:a,value:"。\n将"},{type:b,tag:e,props:{},children:[{type:a,value:E}]},{type:a,value:"的数据rehash到"},{type:b,tag:e,props:{},children:[{type:a,value:q}]},{type:a,value:"里，完成后将"},{type:b,tag:e,props:{},children:[{type:a,value:q}]},{type:a,value:"改为"},{type:b,tag:e,props:{},children:[{type:a,value:E}]},{type:a,value:"，"},{type:b,tag:e,props:{},children:[{type:a,value:q}]},{type:a,value:"改置空。\n并且避免数据量大时rehash导致卡顿。所以会使用渐进式rehash。\n也就是会初始化一个新的"},{type:b,tag:e,props:{},children:[{type:a,value:q}]},{type:a,value:"，在每次增删查改的时候，把"},{type:b,tag:e,props:{},children:[{type:a,value:E}]},{type:a,value:"rehash到"},{type:b,tag:e,props:{},children:[{type:a,value:q}]},{type:a,value:"，把rehashidx+1。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:D,props:{alt:w,"data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200603\u002Fuser-gold-cdn.xitu.io-2019-9-6-16d04a318d3796f5.jpg.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:p,props:{id:A},children:[{type:b,tag:g,props:{href:"#set",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:A}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"redis的set在数据量不大的时候会时候"},{type:b,tag:e,props:{},children:[{type:a,value:"整数集合(intset)"}]},{type:a,value:"的结构，如果数据量大的话，则使用hash来保存。\nintset包含三个字段，分别是"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{},children:[{type:a,value:"contents[]"}]},{type:a,value:"：正数数组，从小到大排序，不重复"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{},children:[{type:a,value:"length"}]},{type:a,value:"：元素数量"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:e,props:{},children:[{type:a,value:"encoding"}]},{type:a,value:"：编码方式"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:p,props:{id:K},children:[{type:b,tag:g,props:{href:"#sorted-set",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:L}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"sorted set的底层结构是"},{type:b,tag:e,props:{},children:[{type:a,value:"跳跃表"}]},{type:a,value:"。跳跃表其实就是多层的链表，每一次链表都是有序的。\n底层链表包含着全部的节点，新增节点时，首先节点肯定是在底层链表里的。\n然后这个节点有50%的机会向上一层，所以一二三层节点的概率为0.5,0.25,0.125……。\n查找是从上层链表查起，比较大小之后逐层往下，知道找到或者在底层也找不到数据为止。\n查找、增删的时间复杂度是logN。\n由于是随机定节点所在的层，所以跳跃表只是大致均匀，不同于普通二叉树的不均匀和红黑树的严格均匀。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:D,props:{alt:w,"data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200603\u002Fuser-gold-cdn.xitu.io-2019-9-6-16d04a318db56821.jpg.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:n,props:{id:"redis过期策略"},children:[{type:b,tag:g,props:{href:"#redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:"Redis过期策略"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"定期删除：每隔一段时间随机抽一些key看看过期了没，过期了清掉"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"惰性删除：当某个key被查询到，先检查这个key过期了没，过期了清掉，返回空"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"定时删除：每个key设置一个定时器，时间到了就删除此key"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"定期删除+惰性删除，但是会导致大量过期key积累，耗尽内存"}]},{type:a,value:c},{type:b,tag:n,props:{id:T},children:[{type:b,tag:g,props:{href:"#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:T}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"noeviction: 写入新数据就报错"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"allkeys-lru：删除最少使用key（最常使用，可以简单用LinkedHashMap实现）"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"allkeys-random：删除随机key"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"volatile-lru：删除有过期时间的最少使用key"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"volatile-random：删除有过期时间的随机key"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"volatile-ttl：删除最快过期的key"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:n,props:{id:"缓存淘汰算法lrulfu"},children:[{type:b,tag:g,props:{href:"#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95lrulfu",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:"缓存淘汰算法（LRU、LFU）"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"LRU：如果数据在列表里，则把数据移到顶部。如果不在则弹出底部数据，插入新数据。\njava里可以用LinkedHashMap简单实现，用remove来get，之后put回去。但是没相应的api删除底部数据。\n也可以map+双向链表实现。链表用于增删数据。map用于查找，key-链表节点。\nmap可以参考ThreadLocal用弱引用，或者能通过链表节点获取key。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"redis的LRU，对象维护一个24位的时间戳作为最后活跃时间。\n当要清理数据时，会随机拿出N个对象（默认五个），删除活跃时间最久远的那个。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"但是活跃最久远不等于最不活跃，所以LFU改造了时间戳，前16位表示时间，后八位表示活跃频率。\nLFU会根据时间长短和活跃频率来权衡活跃程度。为了避免删除新键，可以对新键设置默认活跃频率。"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:D,props:{alt:w,"data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200603\u002Fupload-images.jianshu.io-upload_images-12062369-7fae1afe70569623.png.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:n,props:{id:"redis持久化"},children:[{type:b,tag:g,props:{href:"#redis%E6%8C%81%E4%B9%85%E5%8C%96",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:"Redis持久化"}]},{type:a,value:c},{type:b,tag:p,props:{id:M},children:[{type:b,tag:g,props:{href:"#rdb",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:N}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"fork一个子进程进行RDB持久化，不用线程是避免锁竞争"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"父进程和子进程共享内存，操作系统会对内存进行分页"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"当父进程需要修改数据时，会把相应的内存页复制一份，子进程看到的内存依然是不变的"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"RDB可以设置多久之内有多少个数据发送改变就触发持久化"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"备份间隔长，丢的数据比较多"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"对性能影响小，适合做冷备份"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"重启恢复速度比AOP快"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:p,props:{id:O},children:[{type:b,tag:g,props:{href:"#aof",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:P}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"所以写命令会写入aof缓存，子进程根据策略追加到文件里（例如每秒）"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"当AOF文件过大，进行重写压缩的时候会生成新的文件，旧的文件照常写入"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"一般是RDB和AOF两种都同时开启，这样既能RDB的快速恢复，也有AOF的少丢数据"}]},{type:a,value:c},{type:b,tag:n,props:{id:"redis主从架构"},children:[{type:b,tag:g,props:{href:"#redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:"Redis主从架构"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"对于缓存一般都是支持读高并发，所以使用一主多从，写在主节点，读在从节点。主节点必须开启持久化。"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"当从节点初次连接到主节点，会触发一次全量复制"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"主节点会起一个线程生产一个RDB快照，同时将接受到的写命令缓存到内存里"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"主节点会把RDB快照发给从节点，从节点会把RDB文件保存到硬盘里"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"从节点会清空自己的数据，加载RDB数据到内存里。期间以旧数据对外提供服务"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"如果因为RDB文件过大等原因，导致复制时间超时(默认60s)会认为复制失败"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"主节点会把内存里缓存的写命令发给从节点"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"主节点会在内存里维护一个backlog，以及主从节点都会保存一个replica offset"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"如果主从网络断开，恢复时会从上次的replica offset里继续复制数据"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"如果找不到对应的replica offset，则会触发一次全量复制"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:n,props:{id:"redis哨兵集群"},children:[{type:b,tag:g,props:{href:"#redis%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:"Redis哨兵集群"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"集群监控：负责监控集群的节点是否正常\n"},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"每隔1s对节点发ping心跳检测，如果超时时间内没有回应，则为主观下线"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"询问其他哨兵节点此节点的状态，如果超半数都主观下线，则为客观下线"}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"故障转移：如果主节点挂了，会转移到从节点上\n"},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"哨兵集群选出领导者"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"剔除下线和未主从同步时间过长的从节点"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"同步偏移量最大-\u003E运行ID最小，选择新的主节点"}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"消息通知：将新主节点信息通知客户端"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"配置中心：客户端可在哨兵节点获取主节点信息"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:p,props:{id:B},children:[{type:b,tag:g,props:{href:"#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"每个发现主观下线的哨兵节点向其他哨兵节点发送命令，请求自己成为领导者"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"同意第一个请求，拒接其他请求"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"如果哨兵节点发现自己获得过半数票，则为领导者"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"如果有多个领导者，稍后再试"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"哨兵节点至少三个或以上（两个哨兵节点共同决策，如故障转移。所以最少要三个节点，保证哨兵集群的高可用）"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:p,props:{id:C},children:[{type:b,tag:g,props:{href:"#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:C}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"故障转移后，从节点没完整复制数据"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"主节点脱离了正常网络但还运行着，故障转移后就有两个主节点。\n客户端可能还没来得及切换主节点，导致往旧主节点写数据。\n当旧主节点网络恢复加入集群成为从节点，就会被清空数据"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"可以配置使主节点至少跟一个从节点的数据同步少于10s，大于就拒绝写操作"}]},{type:a,value:c},{type:b,tag:n,props:{id:U},children:[{type:b,tag:g,props:{href:"#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:U}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"使用"},{type:b,tag:e,props:{},children:[{type:a,value:"CRC16(key) & 16384"}]},{type:a,value:"将key分派到一万六千多个槽的其中一个"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"槽的数量是固定的，集群的每一个主节点负责一部分的槽"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"客户端连接到集群的某个节点，如果key对应的槽在本节点就直接处理"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"否则会告知客户端槽所在节点的信息，让客户端再去自行请求"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"集群节点之间是网状结构，每个节点都会与其他节点保存连接，并且传播加入和离开的节点信息与槽信息"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"所以新加和删除节点，通过迁移槽和槽数据，迁移完成后刷新槽信息"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"如果某个节点ping另外的节点，在超时时间内都没有效响应，则为主观下线"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"节点会向其他节点询问，如果过半数节点都认为下线了，则为客观下线"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"从节点根据自己的同步偏移量设置参与选举时间。同步越全则选举越早"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"全部主节点给从节点投票，过半数者成为新的主节点"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:n,props:{id:V},children:[{type:b,tag:g,props:{href:"#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:V}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"由于缓存被删除\u002F过期\u002F宕机导致请求都到了数据库里"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"事前：高可用，主从哨兵或者Redis集群"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"事中：使用本地缓存、服务限流降级，避免数据库被打死"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"事后：使用RDB\u002FAOF重启恢复redis数据"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:n,props:{id:W},children:[{type:b,tag:g,props:{href:"#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:W}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"编造大量不正常数据，无缓存，导致都打到数据库"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"检查数据合法性"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"将这些数据也缓存到Redis里"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:n,props:{id:X},children:[{type:b,tag:g,props:{href:"#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:X}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"热点数据过期，大量请求打到数据库"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"基本不跟新，考虑将数据设置为不过期"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"用Redis锁进行更新"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"起一个定时任务主动更新"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:n,props:{id:Y},children:[{type:b,tag:g,props:{href:"#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7",ariaHidden:i,tabIndex:j},children:[{type:b,tag:k,props:{className:[l,m]},children:[]}]},{type:a,value:Y}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"先更新数据库再删除缓存，缓存lazy生成"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fdoocs.github.io\u002Fadvanced-java\u002F#\u002F.\u002Fdocs\u002Fhigh-concurrency\u002Fredis-consistence",rel:[r,s,t],target:u},children:[{type:a,value:"如何保证缓存与数据库双写一致性？"}]},{type:a,value:"里说的："}]},{type:a,value:c},{type:b,tag:"blockquote",props:{},children:[{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。\n解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。\n因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"我觉得是无稽之谈，缓存数据不是一般都有过期时间吗，过期兜底不就好了吗？\n为什么redis删数据失败，读数据还能成功？这时候是不是应该考虑一下是不是redis挂了？\n先删了缓存，还没改数据库的数据又被其他请求查回缓存里了，不也一样导致不一致吗？"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"参考文章："}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fwww.liritian.com\u002F2020\u002F04\u002F15\u002Fredis-%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f-redis-cluster\u002F",rel:[r,s,t],target:u},children:[{type:a,value:"Redis 集群模式 Redis Cluster"}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fphachon.com\u002Fredis\u002Fredis-3.html",rel:[r,s,t],target:u},children:[{type:a,value:"Redis系列（三）：Redis Cluster集群模式"}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fwww.jianshu.com\u002Fp\u002F5359e7aa5bbe",rel:[r,s,t],target:u},children:[{type:a,value:"Redis为什么又引入了多线程？作者也逃不过“真香定理”？"}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"http:\u002F\u002Fwww.baowenwei.com\u002Fpost\u002Ffen-bu-shi\u002Fredisshe-ji-yuan-li-zhi-di-ceng-shu-ju-jie-gou",rel:[r,s,t],target:u},children:[{type:a,value:"Redis设计原理之底层8种数据结构(一)"}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fi6448038.github.io\u002F2019\u002F12\u002F01\u002Fredis-data-struct\u002F",rel:[r,s,t],target:u},children:[{type:a,value:"图解redis五种数据结构底层实现(动图哦)"}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fjuejin.im\u002Fpost\u002F5d71d3bee51d453b5f1a04f1",rel:[r,s,t],target:u},children:[{type:a,value:"深入了解Redis底层数据结构"}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fjuejin.im\u002Fpost\u002F5cee9fdf6fb9a07ec42b3eca",rel:[r,s,t],target:u},children:[{type:a,value:"浅谈Redis五种数据结构的底层原理"}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Fjuejin.im\u002Fpost\u002F5b53ee7e5188251aaa2d2e16",rel:[r,s,t],target:u},children:[{type:a,value:"通俗易懂的Redis数据结构基础教程"}]}]}]},excerpt:{type:Q,children:[]},dir:Z,path:"\u002F中间件\u002F20200603\u002FRedis总结",extension:".md",title:I,url:"\u002Fblog-code\u002Fview\u002F中间件\u002F20200603\u002FRedis总结\u002F",createAt:new Date(1591142400000),updateAt:new Date(1591142400000),attributes:[{name:"createAt",value:_},{name:"updateAt",value:_},{name:"sort",value:Z,url:"\u002Fblog-code\u002Fpage\u002F中间件\u002F20200603\u002F1\u002F"}]}}],fetch:{},mutations:void 0}}("text","element","\n","li","code","p","a","ul","true",-1,"span","icon","icon-link","h1",2,"h2","ht[1]","nofollow","noopener","noreferrer","_blank","wide","","hash","string","list","set","哨兵集群选举","哨兵集群的数据丢失","img","ht[0]","无名の窝",10000,"青春猪头-牧之原翔子-江之岛","Redis总结","2020-06-03T00:00:00.000Z","sorted-set","sorted set","rdb","RDB","aof","AOF","root","缓存作用","的2^n大小的","缓存淘汰策略","集群模式","缓存雪崩","缓存穿透","缓存击穿","缓存与数据库的一致性","\u002F中间件\u002F20200603","2020-06-03")));