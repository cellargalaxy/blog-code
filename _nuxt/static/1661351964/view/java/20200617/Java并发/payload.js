__NUXT_JSONP__("/view/java/20200617/Java%E5%B9%B6%E5%8F%91", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae){return {data:[{siteConfig:{siteName:H,siteHost:"https:\u002F\u002Fcellargalaxy.github.io",basePath:"\u002Fblog-code\u002F",navs:[{text:"文章",url:"\u002Fblog-code\u002Fpage\u002F1\u002F"},{text:"归档",url:"\u002Fblog-code\u002Farchive\u002F0\u002F"},{text:"画画",url:"\u002Fblog-code\u002Fhtml\u002Fhua.html"},{text:"开源",url:"\u002Fblog-code\u002Fhttps:\u002Fgithub.com\u002Fcellargalaxy\u002Fblog-vue"}],pageSize:10,urlReplace:{"^/file/blog/code":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode"},backgroundImage:{duration:I,fade:1000,images:[{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FcofTzDQXitjeVZ6.jpg",description:J,type:p},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FsfaRJ2lVeM3NDbE.jpg",description:J,type:p},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F26\u002FKybiTdftam5Su7x.jpg",description:"青春猪头-双葉理央",type:p},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F09\u002F08\u002FxdX73nfs24qgOYk.jpg",description:"京吹-明日香,久美子",type:p},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F14\u002FMAiruNcEFW2HYtg.jpg",description:"终将成为你-七海灯子,小糸侑",type:p},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F05\u002FEojdAxTDJsFpbPw.jpg",description:"玉子市场-北白川玉子",type:p},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F31\u002FAXxwJDRS9fmN2uU.jpg",description:"fate_hf-弓道馆",type:p},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F01\u002FaHhVObpJus6dnM4.jpg",description:"fate_hf-樱花树",type:p}]}},homeConfig:{brandInterval:I,brands:[{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F21\u002FmMEAnwY5XPC2pFb.jpg",title:"日常",texts:["我们所度过的每个平凡的日常，也许就是连续不断发生的奇迹。","日々、私たちが過ごしている日常は、実は奇跡の連続なのかもしれない。"]},{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F04\u002F19\u002FH1MmXb9xPcYEhT2.jpg",title:"昨日之歌",texts:["时间梭梭箭如飞，人道漫漫步蹒跚","人間そんな変わるもんじゃないのに、月日ばっかどんどん過ぎて"]}],navs:[{text:"Github",url:"https:\u002F\u002Fgithub.com\u002Fcellargalaxy\u002F"}]},pageFootConfig:{lines:[[{text:"Copyright © 2017-? ."},{text:"备案？不存在的"},{text:"Powered by Nuxt.js & Github"}]]},buildTime:new Date(1661351970662),siteName:H,file:{slug:K,description:"java内存模型(JMM)\nJMM模型下，每个线程都有自己的本地内存，线程对内存的操作也是先操作本地内存。\n之后才将本地内存的数据刷新到主内存里，让各个线程更新共享。",createdAt:L,updatedAt:L,toc:[{id:x,depth:r,text:x},{id:y,depth:r,text:y},{id:z,depth:r,text:z},{id:A,depth:r,text:A},{id:B,depth:r,text:B},{id:C,depth:r,text:C},{id:D,depth:r,text:D}],body:{type:M,children:[{type:b,tag:q,props:{id:N},children:[{type:b,tag:f,props:{href:O,ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:P}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:Q}]},{type:a,value:c},{type:a,value:c},{type:b,tag:q,props:{id:R},children:[{type:b,tag:f,props:{href:"#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:R}]},{type:a,value:c},{type:b,tag:G,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"读读屏障：确保"},{type:b,tag:o,props:{},children:[{type:a,value:"读1"}]},{type:a,value:"读取数据后才进行"},{type:b,tag:o,props:{},children:[{type:a,value:"读2"}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"写写屏障：确保"},{type:b,tag:o,props:{},children:[{type:a,value:"写1"}]},{type:a,value:S},{type:b,tag:o,props:{},children:[{type:a,value:"写2"}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"读写屏障：确保"},{type:b,tag:o,props:{},children:[{type:a,value:T}]},{type:a,value:"之后才"},{type:b,tag:o,props:{},children:[{type:a,value:U}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"写读屏障：确保"},{type:b,tag:o,props:{},children:[{type:a,value:U}]},{type:a,value:S},{type:b,tag:o,props:{},children:[{type:a,value:T}]}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:q,props:{id:V},children:[{type:b,tag:f,props:{href:"#volatile",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:V}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"volatile通过写写屏障，确保volatile变量写入后能立即被其他线程可见，并且后面的写不会在volatile之前写入。\n以及双重检查锁定与延迟初始化问题。"}]},{type:a,value:c},{type:b,tag:q,props:{id:W},children:[{type:b,tag:f,props:{href:"#final",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:W}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"final通过写写屏障，确保final变量写入后能立即被其他线程可见。\n并且final变量的写入早于对象的赋值写入，确保拿到该对象的线程的final变量已经完成初始化。\n所以如果在构造函数里向其他线程传递"},{type:b,tag:m,props:{},children:[{type:a,value:"this"}]},{type:a,value:"，可能会导致final溢出。"}]},{type:a,value:c},{type:b,tag:q,props:{id:X},children:[{type:b,tag:f,props:{href:"#synchronized",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:X}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"java对象的内存结构分为三部分：对象头、实例数据、对其填充。\n其中对象头又由markWord、类型指针、数组长度构成。\n其中markWord保存着锁标志位和是否偏向锁，分别表示锁的状态是无锁、偏向锁、轻量级锁、重量级锁。\n而synchronized在这三种锁的升级叫做"},{type:b,tag:o,props:{},children:[{type:a,value:"锁膨胀"}]},{type:a,value:"。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:"img",props:{alt:"","data-src":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200617\u002Fuser-gold-cdn.xitu.io-2019-3-22-169a410864053e99.jpg.JPEG"},children:[]}]},{type:a,value:c},{type:b,tag:s,props:{id:x},children:[{type:b,tag:f,props:{href:"#%E5%81%8F%E5%90%91%E9%94%81",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:x}]},{type:a,value:c},{type:b,tag:E,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"当锁对象第一次被线程获取时，锁标记位为偏向锁"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"通过CAS把markWord的线程ID指向自己，以后进入锁只需要检查markWord的线程ID是不是指向自己即可"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果线程ID不是当前线程，则证明已经有其他线程占有这个偏向锁，等持锁线程到达安全点后挂起线程。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"如果持锁线程未活动或者已退出同步块，则撤销偏向锁为无锁，唤醒原持锁线程继续执行。\n如果持锁线程还在同步代码块，升级为轻量级锁。对持锁线程执行轻量级锁获取锁过程，唤醒持锁线程继续执行。"}]},{type:a,value:c},{type:b,tag:s,props:{id:y},children:[{type:b,tag:f,props:{href:"#%E8%8E%B7%E5%8F%96%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:y}]},{type:a,value:c},{type:b,tag:E,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果对象为无锁或者轻量级锁，在线程的栈帧里创建一个锁记录的空间，用于保存锁对象的markWord"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"通过CAS把锁对象的markWord更新为栈帧里锁记录的指针，如果成功则获取锁，并且将锁记录的锁标记位修改为轻量级锁"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果失败，意味着markWord已经被修改过，检查markWord是否指向自己的锁记录，如果是则是重入，获取锁成功"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果失败则证明发生了竞争，自适应自旋CAS修改锁记录指针。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"自适应自旋会根据以前自旋成功率来决定自旋次数，越成功自旋越多，否则可能取消自旋直接挂起。\n5. 如果自旋修改失败，升级为重量级锁。锁标记位修改为重量级锁，markWord指向"},{type:b,tag:m,props:{},children:[{type:a,value:Y}]},{type:a,value:"对象指针，线程进入阻塞状态"}]},{type:a,value:c},{type:b,tag:s,props:{id:z},children:[{type:b,tag:f,props:{href:"#%E9%87%8A%E6%94%BE%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:z}]},{type:a,value:c},{type:b,tag:E,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"通过CAS把锁记录的markWord复制回锁对象，成功则释放锁成功，锁标记恢复为无锁"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果失败则证明已经升级为重量级锁，释放锁后唤醒阻塞线程"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:s,props:{id:A},children:[{type:b,tag:f,props:{href:"#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:A}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"每个锁对象其实都是一个监视器锁"},{type:b,tag:m,props:{},children:[{type:a,value:Y}]},{type:a,value:"对象，监视器锁会记录进入数，来实现锁重入。\n在同步代码块里，字节码是通过"},{type:b,tag:m,props:{},children:[{type:a,value:"monitorenter"}]},{type:a,value:"指令获取监视器锁的所有权，和"},{type:b,tag:m,props:{},children:[{type:a,value:"monitorexit"}]},{type:a,value:"指令释放所有权。\n在同步方法里，字节码是通过"},{type:b,tag:m,props:{},children:[{type:a,value:"ACC_SYNCHRONIZED"}]},{type:a,value:"标识，来给JVM标记要去获取监视器锁。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"而监视器锁是依赖操作系统的互斥量"},{type:b,tag:m,props:{},children:[{type:a,value:"mutex"}]},{type:a,value:"，需要将线程从用户态切换到内核态。\n获取锁失败的线程会被放到一个同步队列里面。\n如果释放锁的时候刚好有线程取锁，操作系统会将锁给这个线程，所以重量级锁是非公平锁。\n同时"},{type:b,tag:m,props:{},children:[{type:a,value:"wait()"}]},{type:a,value:"、"},{type:b,tag:m,props:{},children:[{type:a,value:"notify()"}]},{type:a,value:"方法也是依赖于监视器锁，所以调用需要在同步块里。"}]},{type:a,value:c},{type:b,tag:s,props:{id:B},children:[{type:b,tag:f,props:{href:"#%E9%94%81%E6%B6%88%E9%99%A4",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"JVM通过逃逸分析发现某些对象不会发生并发问题，但却加了锁，会去除这个锁。"}]},{type:a,value:c},{type:b,tag:s,props:{id:C},children:[{type:b,tag:f,props:{href:"#%E9%94%81%E4%BC%98%E5%8C%96",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:C}]},{type:a,value:c},{type:b,tag:G,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"读写锁"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"锁粗化：避免反复获取锁，在锁的范围扩大，一次锁处理更多东西"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"减少锁的颗粒度"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"减少锁的持有时间"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:q,props:{id:Z},children:[{type:b,tag:f,props:{href:"#%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:Z}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"队列同步器（AbstractQueuedSynchronizer）是实现各种Lock和并发工具的核心。\n队列同步器最主要是通过一个volatile的int变量来表示锁状态，和维护一个队列用于保存等待锁的线程。\n一般我们是通过继承队列同步器，去重写他的模板方法，在模板方法里通过CAS去修改锁状态。\n模板方法分为两类，独占式和共享式。"}]},{type:a,value:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{type:b,tag:_,props:{},children:[{type:b,tag:$,props:{},children:[{type:b,tag:n,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:"锁标记方法"}]},{type:b,tag:F,props:{},children:[{type:a,value:aa}]}]}]},{type:b,tag:ab,props:{},children:[{type:b,tag:n,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"int getState()"}]},{type:b,tag:g,props:{},children:[{type:a,value:"获取锁标记"}]}]},{type:b,tag:n,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"void setState(int)"}]},{type:b,tag:g,props:{},children:[{type:a,value:"设置锁标记"}]}]},{type:b,tag:n,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"boolean compareAndSetState(int expect,int update)"}]},{type:b,tag:g,props:{},children:[{type:a,value:"CAS锁标记"}]}]}]}]},{type:a,value:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{type:b,tag:_,props:{},children:[{type:b,tag:$,props:{},children:[{type:b,tag:n,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:"模板方法"}]},{type:b,tag:F,props:{},children:[{type:a,value:aa}]}]}]},{type:b,tag:ab,props:{},children:[{type:b,tag:n,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"boolean tryAcquire(int)"}]},{type:b,tag:g,props:{},children:[{type:a,value:"独占式，尝试，获取锁"}]}]},{type:b,tag:n,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"boolean tryRelease(int)"}]},{type:b,tag:g,props:{},children:[{type:a,value:"独占式，尝试，释放锁"}]}]},{type:b,tag:n,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"boolean tryAcquireShared(int)"}]},{type:b,tag:g,props:{},children:[{type:a,value:"共享式，尝试，获取锁"}]}]},{type:b,tag:n,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"boolean tryReleaseShared(int)"}]},{type:b,tag:g,props:{},children:[{type:a,value:"共享式，尝试，释放锁"}]}]},{type:b,tag:n,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"boolean isHeldExclusively()"}]},{type:b,tag:g,props:{},children:[{type:a,value:"锁是否被当前线程独占"}]}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"以重入锁为例，当调用锁方法的时候，会调用尝试获取锁方法。\n还没有加锁就通过CAS尝试加锁。如果加锁了锁，就判断持锁线程是不是当前线程，是的话就锁标记+1重入。\n而重入锁支持非公平锁和公平锁，非公平锁会先通过CAS抢锁。\n而公平锁则先判断等待队列里是否有线程在等待，有的话则不去抢锁。\n如果CAS获取锁失败的话，AQS会把线程封装到等待队列的节点里，通过CAS把节点加到队尾。\n线程被加到队尾之后，会有个去死循环判断："}]},{type:a,value:c},{type:b,tag:E,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"前置节点是不是头结点（头结点不记数据），是的话就通过CAS拿锁，失败继续循环"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"前置节点是不是在休眠状态，是的话自己也休眠，等待唤醒，调用"},{type:b,tag:m,props:{},children:[{type:a,value:"LockSupport.park()"}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果醒来发现自己被interrupt的话，返回获取锁失败，并interrupt自己，保存interrupt状态为true"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"释放锁会调用尝试释放锁方法，如果当前线程不是持锁线程则抛异常，否则修改锁标记。\n修改成功之后回去唤醒等待队列里最前面的还在等待获取锁的线程。"}]},{type:a,value:c},{type:b,tag:q,props:{id:"juc"},children:[{type:b,tag:f,props:{href:"#juc",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:"JUC"}]},{type:a,value:c},{type:b,tag:G,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Semaphore（信号量）：控制并发量。通过锁标记来记录并发数。"},{type:b,tag:m,props:{},children:[{type:a,value:"acquire()"}]},{type:a,value:"方法获取锁，"},{type:b,tag:m,props:{},children:[{type:a,value:"release()"}]},{type:a,value:"方法释放锁。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"CountDownLatch（减数门栓）：锁标记记录未完成剩余计数。线程完成后调用"},{type:b,tag:m,props:{},children:[{type:a,value:"countDown()"}]},{type:a,value:"计数-1，直到计数为0，唤醒被"},{type:b,tag:m,props:{},children:[{type:a,value:ac}]},{type:a,value:"阻塞的线程。\n例如主线程需要等待多个组件加载完成，或者一个线程指挥多个线程同时开始。\n但是CountDownLatch的计数无法重置，所以CountDownLatch对象是一次性的。"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"CyclicBarrier（循环栅栏）：锁标记记录未完成剩余计数。线程调用"},{type:b,tag:m,props:{},children:[{type:a,value:ac}]},{type:a,value:"计数-1并阻塞，直到全部线程完成，计数为0才被唤醒。\n多线程计算，并发计算完成一步之后，在计算下一步。\nCyclicBarrier有reset功能，可以多次使用。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:s,props:{id:D},children:[{type:b,tag:f,props:{href:"#%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%8E%E9%94%81%E9%99%8D%E7%BA%A7",ariaHidden:h,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:D}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"锁降级发生于读写锁，当我们检查数据后发现需要修改数据的情形。\n因此我们需要先获取读锁检查数据，再使用写锁修改数据。\n但如果是先释放读锁再去获取写锁，则可能会有其他线程在这个空缺时间里拿到写锁修改了数据。\n所以是获取读锁-\u003E检查数据-\u003E获取写锁-\u003E释放读锁-\u003E修改数据-\u003E释放写锁。\n这里的在持有读锁状态下获取写锁，然后释放读锁保留写锁，即读锁-\u003E写锁，就叫做锁升级。\n反之，如果是持有写锁状态下去获取读锁，然后释放写锁保留读锁，即写锁-\u003E读锁，则叫做锁降级。\n无论是锁升级还是锁降级，目的都是确保读写的数据的一致性，有点像一个事务。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"参考文章："}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"《深入理解Java虚拟机_JVM高级特性与最佳实践_第3版_周志明》"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fjuejin.im\u002Fpost\u002F5c936018f265da60ec281bcb",rel:[t,u,v],target:w},children:[{type:a,value:"深入分析synchronized原理和锁膨胀过程(二)"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Ftech.meituan.com\u002F2018\u002F11\u002F15\u002Fjava-lock.html",rel:[t,u,v],target:w},children:[{type:a,value:"不可不说的Java“锁”事"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"http:\u002F\u002Flitroi.com\u002Fpublic\u002FarticleDetail?artId=20181015154804936010000",rel:[t,u,v],target:w},children:[{type:a,value:"并发之AQS原理(三)+如何保证并发"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fjuejin.im\u002Fpost\u002F5c739c5cf265da2dd8689b46",rel:[t,u,v],target:w},children:[{type:a,value:"AQS原理学习笔记"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fgithub.com\u002FSnailclimb\u002FJavaGuide\u002Fblob\u002Fmaster\u002Fdocs\u002Fjava\u002FMultithread\u002FAQS.md",rel:[t,u,v],target:w},children:[{type:a,value:"AQS.md"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Ftech.meituan.com\u002F2019\u002F12\u002F05\u002Faqs-theory-and-apply.html",rel:[t,u,v],target:w},children:[{type:a,value:"从ReentrantLock的实现看AQS的原理及应用"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fcode.cellargalaxy.top\u002Farticle\u002Fjava\u002F20180204\u002Fjava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\u002F",rel:[t,u,v],target:w},children:[{type:a,value:"java并发编程的艺术学习笔记"}]}]}]},excerpt:{type:M,children:[{type:b,tag:q,props:{id:N},children:[{type:b,tag:f,props:{ariaHidden:h,href:O,tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:P}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:Q}]}]},dir:ad,path:"\u002Fjava\u002F20200617\u002FJava并发",extension:".md",title:K,url:"\u002Fblog-code\u002Fview\u002Fjava\u002F20200617\u002FJava并发\u002F",createAt:new Date(1592352000000),updateAt:new Date(1592352000000),attributes:[{name:"createAt",value:ae},{name:"updateAt",value:ae},{name:"sort",value:ad,url:"\u002Fblog-code\u002Fpage\u002Fjava\u002F20200617\u002F1\u002F"}]}}],fetch:{},mutations:void 0}}("text","element","\n","p","li","a","td","true",-1,"span","icon","icon-link","code","tr","strong","wide","h1",2,"h2","nofollow","noopener","noreferrer","_blank","偏向锁","获取轻量级锁","释放轻量级锁","重量级锁","锁消除","锁优化","锁升级与锁降级","ol","th","ul","无名の窝",10000,"青春猪头-牧之原翔子-江之岛","Java并发","2020-06-17T00:00:00.000Z","root","java内存模型jmm","#java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm","java内存模型(JMM)","JMM模型下，每个线程都有自己的本地内存，线程对内存的操作也是先操作本地内存。\n之后才将本地内存的数据刷新到主内存里，让各个线程更新共享。","内存屏障","其他线程可见后才","读","写","volatile","final","synchronized","monitor","队列同步器","table","thead","功能","tbody","await()","\u002Fjava\u002F20200617","2020-06-17")));