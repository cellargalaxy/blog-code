__NUXT_JSONP__("/view/$E4$B8$AD$E9$97$B4$E4$BB$B6/20220304/RocksDB$E5$88$9D$E6$AD$A5$E4$BA$86$E8$A7$A3", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M){return {data:[{siteConfig:{siteName:w,siteHost:"https:\u002F\u002Fcellargalaxy.github.io",basePath:"\u002Fblog-code\u002F",navs:[{text:"文章",url:"\u002Fblog-code\u002Fpage\u002F1\u002F"},{text:"归档",url:"\u002Fblog-code\u002Farchive\u002F0\u002F"},{text:"画画",url:"\u002Fblog-code\u002Fhtml\u002Fhua.html"},{text:"开源",url:"\u002Fblog-code\u002Fhttps:\u002Fgithub.com\u002Fcellargalaxy\u002Fblog-vue"}],pageSize:10,urlReplace:{"^/file/blog/code":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode"},backgroundImage:{duration:x,fade:1000,images:[{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FcofTzDQXitjeVZ6.jpg",description:y,type:l},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FsfaRJ2lVeM3NDbE.jpg",description:y,type:l},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F26\u002FKybiTdftam5Su7x.jpg",description:"青春猪头-双葉理央",type:l},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F09\u002F08\u002FxdX73nfs24qgOYk.jpg",description:"京吹-明日香,久美子",type:l},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F14\u002FMAiruNcEFW2HYtg.jpg",description:"终将成为你-七海灯子,小糸侑",type:l},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F05\u002FEojdAxTDJsFpbPw.jpg",description:"玉子市场-北白川玉子",type:l},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F31\u002FAXxwJDRS9fmN2uU.jpg",description:"fate_hf-弓道馆",type:l},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F01\u002FaHhVObpJus6dnM4.jpg",description:"fate_hf-樱花树",type:l}]}},homeConfig:{brandInterval:x,brands:[{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F21\u002FmMEAnwY5XPC2pFb.jpg",title:"日常",texts:["我们所度过的每个平凡的日常，也许就是连续不断发生的奇迹。","日々、私たちが過ごしている日常は、実は奇跡の連続なのかもしれない。"]},{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F04\u002F19\u002FH1MmXb9xPcYEhT2.jpg",title:"昨日之歌",texts:["时间梭梭箭如飞，人道漫漫步蹒跚","人間そんな変わるもんじゃないのに、月日ばっかどんどん過ぎて"]}],navs:[{text:"Github",url:"https:\u002F\u002Fgithub.com\u002Fcellargalaxy\u002F"}]},pageFootConfig:{lines:[[{text:"Copyright © 2017-? ."},{text:"备案？不存在的"},{text:"Powered by Nuxt.js & Github"}]]},buildTime:new Date(1653109065040),siteName:w,file:{slug:z,description:v,createdAt:"2022-03-04T00:00:00.000Z",updatedAt:"2022-03-07T00:00:00.000Z",toc:[{id:A,depth:m,text:B},{id:o,depth:m,text:o},{id:C,depth:m,text:D},{id:E,depth:3,text:F},{id:p,depth:m,text:p},{id:q,depth:m,text:q},{id:G,depth:m,text:H}],body:{type:I,children:[{type:b,tag:d,props:{},children:[{type:a,value:v}]},{type:a,value:c},{type:a,value:c},{type:b,tag:J,props:{id:"lsm树的实现"},children:[{type:b,tag:f,props:{href:"#lsm%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:"LSM树的实现"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"RocksDB的LSM树的存储结构有三种：WAL+mentable+SSTable"}]},{type:a,value:c},{type:b,tag:n,props:{id:A},children:[{type:b,tag:f,props:{href:"#wal",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"WAL(write-ahead log)(预写式日志)，WAL本质是一个追加写入的硬盘文件，是数据库技术中实现事务的一种标准方法，可以实现单机事务的原子性和持久性，同时提高写入的性能。\n在修改数据时为了实现事务的原子性和持久性，并不会直接修改数据文件，因为一个事务中可能会随机修改多个字段，导致需要修改数据文件的位置也是随机的。\n一是随机IO会影响性能，二是多次的随机IO写入显然无法保证原子性。\n而使用WAL的话，并不会直接去修改数据文件，而是把数据修改的情况都写入WAL里。往WAL里写入的类型有两种，redo执行写操作，undo回滚写操作。\n接下来可能会有五种情况："}]},{type:a,value:c},{type:b,tag:K,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"往WAL写入redo前崩溃了，重启后WAL并没有相关日志：事务无执行，数据文件无影响"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"往WAL写入redo时崩溃了，重启后WAL的日志并不完整：事务取消执行，数据文件无影响"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"往WAL写入redo后崩溃了，重启后WAL的日志写入完整：从WAL中读出所需修改的数据，修改数据文件"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"修改数据文件时崩溃了：从WAL中读出所需修改的数据，继续修改数据文件"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"修改数据文件无法进行：往WAL里写入undo，回滚写操作，事务执行失败"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"使用WAL支持并发读读和读写，由于都是追加写入，不支持并发写写。\n如果需要读最新的数据，则需要往WAL里查询。如果WAL没查到，那数据文件里的就是最新的数据。\n需要注意，写入WAL与修改数据文件并不一定是同步的。往往会合并WAL多个写操作，批量刷入硬盘里。"}]},{type:a,value:c},{type:b,tag:n,props:{id:o},children:[{type:b,tag:f,props:{href:"#mentable",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:o}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"mentable是RocksDB的内存数据结构，使用跳表实现，分为active memtable和immutable memtable两种。\nRocksDB在写入WAL之后，会把数据写到active mentable里。\n如果active mentable被写满，会新建一个active mentable，旧的会变成immutable memtable，等待被异步刷入硬盘里。"}]},{type:a,value:c},{type:b,tag:n,props:{id:C},children:[{type:b,tag:f,props:{href:"#sstable",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:D}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"SSTable，SST文件，全称Sorted String Table，是持久化的，不可改的，有序的数据文件。\nSSTable的文件分为多个区域，内部有索引信息能加快数据查询速度。\nmentable被刷到硬盘里的数据去向就是生成SSTable。\nSST文件都属于某一个层，从L0到Ln，层级越小，数据越新。新生成的SST文件首先会在L0层，但每一层的SST文件数量会有限制。在一定的条件下，会对SST文件进行合并。"}]},{type:a,value:c},{type:b,tag:"h3",props:{id:E},children:[{type:b,tag:f,props:{href:"#compaction",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:F}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"由于RocksDB通过增量写写入mentable，而SST文件数据来源于mentable，所以SST文件的数据的冗余的。\n为了减少冗余，会对SST文件进行合并，删除重复或者过期的key。\n而RocksDB默认是使用Level Style Compaction作为合并策略。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"首先L0的SST文件是从mentable生成的，所以L0的SST文件直接会有重复的key。\n当进行合并时，会选择Ln层的一个文件，与Ln+1的多个文件进行合并，合并相同的key，删除失效key。\n合并后，每一层的SST文件直接都是有顺序的。"}]},{type:a,value:c},{type:b,tag:n,props:{id:p},children:[{type:b,tag:f,props:{href:"#%E8%AF%BB%E6%93%8D%E4%BD%9C",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:p}]},{type:a,value:c},{type:b,tag:L,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"在active mentable里查询"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"在immutable memtable里查询"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"在L0里查询。由于L0可能有重复key，所以才有遍历查询"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"在Ln里查询，由于Ln没有重复key，所以使用二分法查询"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果到Lmax都还查不到，那就是查不到"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:n,props:{id:q},children:[{type:b,tag:f,props:{href:"#%E5%86%99%E6%93%8D%E4%BD%9C",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:q}]},{type:a,value:c},{type:b,tag:L,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"数据写入active mentable"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"active mentable到达一定大小，会转变成immutable memtable，创建新的active mentable继续提供读写"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"满足一定会把immutable memtable刷为硬盘的SST文件。先写入系统缓存页，再异步写入硬盘，考虑到系统奔溃丢缓存页可能性较低，异步写还是可靠的"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:n,props:{id:G},children:[{type:b,tag:f,props:{href:"#column-family",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:H}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"kv存储时需要指定列族(Column Family)，且允许创建多个列族。列族直接使用不同的mentable和SST文件，但是公用一个WAL。\n好处是可以对不同列族的mentable和SST进行不同的配置，提高读写性能。"}]},{type:a,value:c},{type:b,tag:J,props:{id:"lsm树总结"},children:[{type:b,tag:f,props:{href:"#lsm%E6%A0%91%E6%80%BB%E7%BB%93",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:"LSM树总结"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"相比于B+树来说，要在B+树写入随机的数据，写入的节点位置是随机的，随机写入影响着B+树的写入性能。\n而LSM树通过使用WAL，mentable和SST文件，将随机写转换为顺序写，大大提高了写入的性能。\n但顺序写的所带来的代价的空间放大，写放大和读放大。"}]},{type:a,value:c},{type:b,tag:K,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"由于SST文件的冗余性，存储空间被放大"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"同样由于冗余性而需要进行合并，每次合并都进行一次写操作，实际是把每次只需写入一次的数据放大操作了多次写"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"LSM树读取数据需要分层读取多次，读取次数的放大会影响读性能"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"空间放大，写放大和读放大三种需要平衡，RocksDB提供了许多配置来进行微调设置。\n跟B+树相比，B+树对事物支持更好，因为B+树能原地更新数据，并且数据只有一份。而LSM树的key在L0里会重复，只有在进行合并的时候才算完成事物。\nLSM树支持O(1)的写，O(n)的读。而B+树的读写都是O(logN)。通常来说，LSM树的写性能由于B+树，B+树的读性能优于LSM树。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"参考文章"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fsegmentfault.com\u002Fa\u002F1190000041198407",rel:[r,s,t],target:u},children:[{type:a,value:"从 RocksDB 看 LSM-Tree 算法设计"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fflynx.dev\u002Frocksdb\u002F",rel:[r,s,t],target:u},children:[{type:a,value:"一个项目的诞生(三)：RocksDB的价值"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Flessisbetter.site\u002F2020\u002F01\u002F02\u002Fwal-introduction\u002F",rel:[r,s,t],target:u},children:[{type:a,value:"WAL(预写式日志)简介"}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fcloud.tencent.com\u002Fdeveloper\u002Farticle\u002F1623123",rel:[r,s,t],target:u},children:[{type:a,value:"你常听说的WAL到底是什么"}]}]}]},excerpt:{type:I,children:[{type:b,tag:d,props:{},children:[{type:a,value:v}]}]},dir:M,path:"\u002F中间件\u002F20220304\u002FRocksDB初步了解",extension:".md",title:z,url:"\u002Fblog-code\u002Fview\u002F$E4$B8$AD$E9$97$B4$E4$BB$B6\u002F20220304\u002FRocksDB$E5$88$9D$E6$AD$A5$E4$BA$86$E8$A7$A3\u002F",createAt:new Date(1646352000000),updateAt:new Date(1646611200000),attributes:[{name:"createAt",value:"2022-03-04"},{name:"updateAt",value:"2022-03-07"},{name:"sort",value:M,url:"\u002Fblog-code\u002Fpage\u002F$E4$B8$AD$E9$97$B4$E4$BB$B6\u002F20220304\u002F1\u002F"}]}}],fetch:{},mutations:void 0}}("text","element","\n","p","li","a","true",-1,"span","icon","icon-link","wide",2,"h2","mentable","读操作","写操作","nofollow","noopener","noreferrer","_blank","RocksDB是一个嵌入式的KV数据库，由Facebook基于levelDB开发。\n多数情况下，看一把RocksDB看做是一个在本地的，数据落盘的，大数据量的Redis，且访问性能高于远端的Redis。\nRocksDB底层使用LSM树实现，但LSM树实际上并不是一棵具体的树，其实是一套存储处理算法。\nLSM树对KV的持久化，保持较高性能的读的基础上，实现了追加写，提供了写入的性能。","无名の窝",10000,"青春猪头-牧之原翔子-江之岛","RocksDB初步了解","wal","WAL","sstable","SSTable","compaction","Compaction","column-family","Column Family","root","h1","ul","ol","\u002F中间件\u002F20220304")));