__NUXT_JSONP__("/view/%E6%8A%98%E8%85%BE/20180714/Ubuntu%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AERedis%E4%B8%8E%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae){return {data:[{navbarConfig:{brandText:I,brandUrl:"\u002Fblog-code\u002F",navs:[{text:"文章",url:"\u002Fblog-code\u002Fpage\u002F1\u002F"},{text:"归档",url:"\u002Fblog-code\u002Farchive\u002F0\u002F"},{text:"画画",url:"\u002Fblog-code\u002Fhtml\u002Fhua.html"},{text:"开源",url:"\u002Fblog-code\u002Fhttps:\u002Fgithub.com\u002Fcellargalaxy\u002Fblog-vue"}]},homeConfig:{brandInterval:10000,brands:[{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F21\u002FmMEAnwY5XPC2pFb.jpg",title:"日常",texts:["我们所度过的每个平凡的日常，也许就是连续不断发生的奇迹。","日々、私たちが過ごしている日常は、実は奇跡の連続なのかもしれない。"]},{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F04\u002F19\u002FH1MmXb9xPcYEhT2.jpg",title:"昨日之歌",texts:["时间梭梭箭如飞，人道漫漫步蹒跚","人間そんな変わるもんじゃないのに、月日ばっかどんどん過ぎて"]}],navs:[{text:"Github",url:"https:\u002F\u002Fgithub.com\u002Fcellargalaxy\u002F"}]},pageFootConfig:{lines:[[{text:"Copyright © 2017-? ."},{text:"备案？不存在的"},{text:"Powered by Nuxt.js & Github"}]]},buildTime:new Date(1651410200582),siteName:I,file:{slug:J,description:"",createdAt:K,updatedAt:K,toc:[],body:{type:L,children:[{type:a,value:c},{type:b,tag:q,props:{id:M},children:[{type:b,tag:h,props:{href:"#%E5%AE%89%E8%A3%85",ariaHidden:r,tabIndex:s},children:[{type:b,tag:d,props:{className:[t,u]},children:[]}]},{type:a,value:M}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:"安装依旧有两种办法，用apt-get安装和编译安装。用apt-get安装会自动配置为服务并开机自启，下面介绍的是编译安装。"}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:"首先到"},{type:b,tag:h,props:{href:"https:\u002F\u002Fredis.io\u002F",rel:[m,n,o],target:p,title:N},children:[{type:a,value:N}]},{type:a,value:"下载最新的稳定版，我下载的是"},{type:b,tag:h,props:{href:"http:\u002F\u002Fdownload.redis.io\u002Freleases\u002Fredis-4.0.10.tar.gz",rel:[m,n,o],target:p,title:O},children:[{type:a,value:O}]},{type:a,value:"。"}]},{type:a,value:c},{type:b,tag:D,props:{className:[E]},children:[{type:b,tag:F,props:{className:[G,P]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:d,props:{className:[e,j]},children:[{type:a,value:"#下载"}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,k]},children:[{type:a,value:"wget"}]},{type:a,value:" http:\u002F\u002Fdownload.redis.io\u002Freleases\u002Fredis-4.0.10.tar.gz\n"},{type:b,tag:d,props:{className:[e,j]},children:[{type:a,value:"#解压"}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,k]},children:[{type:a,value:"tar"}]},{type:a,value:" -zxvf redis-4.0.10.tar.gz\n"},{type:b,tag:d,props:{className:[e,v,w]},children:[{type:a,value:"cd"}]},{type:a,value:" redis-4.0.10\n"},{type:b,tag:d,props:{className:[e,j]},children:[{type:a,value:"#编译"}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,k]},children:[{type:a,value:H}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,j]},children:[{type:a,value:"#编译后测试，运行测试套件以确保built正确"}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,k]},children:[{type:a,value:H}]},{type:a,value:l},{type:b,tag:d,props:{className:[e,v,w]},children:[{type:a,value:"test"}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,j]},children:[{type:a,value:"#安装"}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,k]},children:[{type:a,value:"sudo"}]},{type:a,value:l},{type:b,tag:d,props:{className:[e,k]},children:[{type:a,value:H}]},{type:a,value:l},{type:b,tag:d,props:{className:[e,k]},children:[{type:a,value:"install"}]},{type:a,value:c}]}]}]},{type:a,value:c},{type:b,tag:q,props:{id:Q},children:[{type:b,tag:h,props:{href:"#%E8%BF%90%E8%A1%8C",ariaHidden:r,tabIndex:s},children:[{type:b,tag:d,props:{className:[t,u]},children:[]}]},{type:a,value:Q}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:"完成后看看"},{type:b,tag:f,props:{},children:[{type:a,value:"\u002Fusr\u002Flocal\u002Fbin\u002F"}]},{type:a,value:"文件夹下有没有redis的软件，试试执行redis的服务端命令"},{type:b,tag:f,props:{},children:[{type:a,value:"redis-server"}]},{type:a,value:"和客户端"},{type:b,tag:f,props:{},children:[{type:a,value:"redis-cli"}]},{type:a,value:"，应该会运行成功。也可以指定配置文件："},{type:b,tag:f,props:{},children:[{type:a,value:"redis-server .\u002Fredis.conf"}]}]},{type:a,value:c},{type:b,tag:q,props:{id:R},children:[{type:b,tag:h,props:{href:"#%E9%85%8D%E7%BD%AE",ariaHidden:r,tabIndex:s},children:[{type:b,tag:d,props:{className:[t,u]},children:[]}]},{type:a,value:R}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:"redis的配置文件模板在解压出来的redis-4.0.10文件夹下有，下面介绍常用参数"}]},{type:a,value:c},{type:b,tag:D,props:{className:[E]},children:[{type:b,tag:F,props:{className:[G,"language-text"]},children:[{type:b,tag:f,props:{},children:[{type:a,value:"#指定内存大小的时候，必须要带上单位，单位不区分大小写\n# 1k =\u003E 1000 bytes\n# 1kb =\u003E 1024 bytes\n# 1m =\u003E 1000000 bytes\n# 1mb =\u003E 1024*1024 bytes\n# 1g =\u003E 1000000000 bytes\n# 1gb =\u003E 1024*1024*1024 bytes\n################################ GENERAL常用  #####################################\n#默认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes。\ndaemonize no\n#监听端口号，默认为 6379，如果你设为 0 ，redis 将不在 socket 上监听任何客户端连接。\nport 6379\n#TCP 监听的最大容纳数量\ntcp-backlog 511\n#默认情况下，redis 在 server 上所有有效的网络接口上监听客户端连接。\n#你如果只想让它在一个网络接口上监听，那你就绑定一个IP或者多个IP。\n#示例，多个IP用空格隔开\n# Examples:\n# bind 192.168.1.100 10.0.0.1\n#指定在一个 client 空闲多少秒之后关闭连接（0 就是不管它）\ntimeout 0\n#tcp 心跳包。\n# TCP keepalive.\n#如果设置为非零，则在与客户端缺乏通讯的时候使用 SO_KEEPALIVE 发送 tcp acks 给客户端。\n#推荐一个合理的值就是300秒\ntcp-keepalive 300\n#定义日志级别。\n#可以是下面的这些值：\n#debug 适用于开发或测试阶段\n# verbose 基本不用的级别.许多很少有用的信息，但不是像调试级别混乱\n# notice 适用于生产环境\n# warning 仅仅一些重要的消息被记录\nloglevel notice\n#指定日志文件的位置\nlogfile \"\"\n#设置数据库的数目。默认数据库是 DB 0，你可以在每个连接上使用 select \u003Cdbid\u003E 命令选择一个不同的数据库，\n#但是 dbid 必须是一个介于 0 到 databasees - 1 之间的值\ndatabases 16\n################################ SNAPSHOTTING快照   ################################\n#存 DB 到磁盘：\n#注意：你可以注释掉所有的 save 行来停用保存功能,也可以直接一个空字符串来实现停用\n#下面的例子的意思是：\n#900 秒内如果至少有 1 个 key 的值变化，则保存\n#300 秒内如果至少有 10 个 key 的值变化，则保存\n#60 秒内如果至少有 10000 个 key 的值变化，则保存\nsave 900 1\nsave 300 10\nsave 60 10000\n#默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，否则就会没人注意到灾难的发生。\nstop-writes-on-bgsave-error yes\n#是否在 dump .rdb 数据库的时候使用 LZF 压缩字符串\nrdbcompression yes\n#是否校验rdb文件\nrdbchecksum yes\n#设置 dump 的文件位置\ndbfilename dump.rdb\n#工作目录\n#例如上面的 dbfilename 只指定了文件名，\n#但是它会写入到这个目录下。这个配置项一定是个目录，而不能是文件名。\ndir .\u002F\n################################# REPLICATION主从复制 #################################\n#设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n# slaveof \u003Cmasterip\u003E \u003Cmasterport\u003E\n#如果master设置了requirepass，那么slave要连上master，需要有master的密码才行。masterauth就是用来配置master的密码，这样可以在连上master后进行认证。\n# masterauth \u003Cmaster-password\u003E\n#设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭\n# requirepass foobared\n################################### LIMITS 限制####################################\n#设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。\n# maxclients 10000\n#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\nappendonly no\n#指定更新日志文件名，默认为appendonly.aof\nappendfilename \"appendonly.aof\"\n#指定更新日志条件，共有3个可选值：\n#no：表示等操作系统进行数据缓存同步到磁盘（快）\n#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）\n#everysec：表示每秒同步一次（折衷，默认值）\n############################## MEMORY MANAGEMENT ################################\n#最大内存使用量\n#maxmemory \u003Cbytes\u003E\n#数据丢弃策略\n#maxmemory-policy noeviction\n############################### ADVANCED CONFIG ###############################\n#定期删除次数，即每秒进行多少次的定期删除\nhz 10\n"}]}]}]},{type:a,value:c},{type:b,tag:q,props:{id:S},children:[{type:b,tag:h,props:{href:"#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5",ariaHidden:r,tabIndex:s},children:[{type:b,tag:d,props:{className:[t,u]},children:[]}]},{type:a,value:S}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:"过期策略有三种：定时删除、定期删除、惰性删除"}]},{type:a,value:c},{type:b,tag:T,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"定时删除是给每个key设置一个定时器，时间到了就删除此key。显然很耗cpu"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"定期删除是redis每隔一段时间就随机抽取一些key检查是否过期，过期则删除。所以如果没有被随机到的过期key依然会保留着。"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"惰性删除是当要获取某个key时，先检查此key是否已经过期，是的话就删除，返回null。这样的话，如果有大量key已经过期但迟迟没有被查询，就会一直保留着。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:"所以一般是使用定期删除搭配懒惰删除。定时删除和懒惰删除没查到在哪配置，定期删除可以在配置文件里配置"},{type:b,tag:f,props:{},children:[{type:a,value:"hz"}]},{type:a,value:"参数。"}]},{type:a,value:c},{type:b,tag:q,props:{id:U},children:[{type:b,tag:h,props:{href:"#%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%E4%B8%8E%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5",ariaHidden:r,tabIndex:s},children:[{type:b,tag:d,props:{className:[t,u]},children:[]}]},{type:a,value:U}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:"内存限制和置换策略如上可以在配置文件里配置，也可以在客户端进行动态配置"}]},{type:a,value:c},{type:b,tag:D,props:{className:[E]},children:[{type:b,tag:F,props:{className:[G,P]},children:[{type:b,tag:f,props:{},children:[{type:b,tag:d,props:{className:[e,j]},children:[{type:a,value:"#配置内存限制"}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,x]},children:[{type:a,value:y}]},{type:a,value:V},{type:b,tag:d,props:{className:[e,z]},children:[{type:a,value:W}]},{type:b,tag:d,props:{className:[e,A]},children:[{type:a,value:B}]},{type:a,value:l},{type:b,tag:d,props:{className:[e,C]},children:[{type:a,value:X}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,z]},children:[{type:a,value:Y}]},{type:b,tag:d,props:{className:[e,A]},children:[{type:a,value:B}]},{type:a,value:l},{type:b,tag:d,props:{className:[e,C]},children:[{type:a,value:"\"0\""}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,x]},children:[{type:a,value:y}]},{type:a,value:Z},{type:b,tag:d,props:{className:[e,v,w]},children:[{type:a,value:_}]},{type:a,value:" maxmemory 100MB\nOK\n"},{type:b,tag:d,props:{className:[e,x]},children:[{type:a,value:y}]},{type:a,value:V},{type:b,tag:d,props:{className:[e,z]},children:[{type:a,value:W}]},{type:b,tag:d,props:{className:[e,A]},children:[{type:a,value:B}]},{type:a,value:l},{type:b,tag:d,props:{className:[e,C]},children:[{type:a,value:X}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,z]},children:[{type:a,value:Y}]},{type:b,tag:d,props:{className:[e,A]},children:[{type:a,value:B}]},{type:a,value:l},{type:b,tag:d,props:{className:[e,C]},children:[{type:a,value:"\"104857600\""}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,j]},children:[{type:a,value:"#置换策略"}]},{type:a,value:c},{type:b,tag:d,props:{className:[e,x]},children:[{type:a,value:y}]},{type:a,value:Z},{type:b,tag:d,props:{className:[e,v,w]},children:[{type:a,value:_}]},{type:a,value:" maxmemory-policy noeviction\n"}]}]}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:"置换策略有6种："}]},{type:a,value:c},{type:b,tag:T,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:"noeviction"}]},{type:a,value:": 不进行置换，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都会返回error"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:"allkeys-lru"}]},{type:a,value:": 优先删除掉最近最不经常使用的key，用以保存新数据"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:"volatile-lru"}]},{type:a,value:": 只从设置失效（expire set）的key中选择最近最不经常使用的key进行删除，用以保存新数据"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:"allkeys-random"}]},{type:a,value:": 随机从all-keys中选择一些key进行删除，用以保存新数据"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:"volatile-random"}]},{type:a,value:": 只从设置失效（expire set）的key中，选择一些key进行删除，用以保存新数据"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:"volatile-ttl"}]},{type:a,value:": 只从设置失效（expire set）的key中，选出存活时间（TTL）最短的key进行删除，用以保存新数据"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:a,value:"参考文献："}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:b,tag:h,props:{href:"https:\u002F\u002Fblog.csdn.net\u002Fzstack_org\u002Farticle\u002Fdetails\u002F69951845",rel:[m,n,o],target:p,title:$},children:[{type:a,value:$}]}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:b,tag:h,props:{href:"https:\u002F\u002Fblog.csdn.net\u002Fjack__frost\u002Farticle\u002Fdetails\u002F67633975",rel:[m,n,o],target:p,title:aa},children:[{type:a,value:aa}]}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:b,tag:h,props:{href:"https:\u002F\u002Fblog.csdn.net\u002Fcjfeii\u002Farticle\u002Fdetails\u002F47259519",rel:[m,n,o],target:p,title:ab},children:[{type:a,value:ab}]}]},{type:a,value:c},{type:b,tag:g,props:{},children:[{type:b,tag:h,props:{href:"https:\u002F\u002Fwww.ecpeng.com\u002F2018\u002F04\u002F16\u002Fredis-key-expire-strategy\u002F",rel:[m,n,o],target:p,title:ac},children:[{type:a,value:ac}]}]}]},excerpt:{type:L,children:[]},dir:ad,path:"\u002F折腾\u002F20180714\u002FUbuntu安装配置Redis与置换策略",extension:".md",title:J,url:"\u002Fblog-code\u002Fview\u002F折腾\u002F20180714\u002FUbuntu安装配置Redis与置换策略",createAt:new Date(1531526400000),updateAt:new Date(1531526400000),attributes:[{name:"createAt",value:ae},{name:"updateAt",value:ae},{name:"sort",value:ad,url:"\u002Fblog-code\u002Fpage\u002F折腾\u002F20180714\u002F1\u002F"}]}}],fetch:{},mutations:void 0}}("text","element","\n","span","token","code","p","a","li","comment","function"," ","nofollow","noopener","noreferrer","_blank","h1","true",-1,"icon","icon-link","builtin","class-name","operator","\u003E","number","punctuation",")","string","div","nuxt-content-highlight","pre","line-numbers","make","无名の窝","Ubuntu安装配置Redis与置换策略","2018-07-14T00:00:00.000Z","root","安装","官网","redis-4.0.10","language-shell","运行","配置","过期策略","ol","内存限制与置换策略"," config get maxmemory\n","1","\"maxmemory\"","2"," config ","set","如何在Ubuntu 16.04上安装并配置Redis","Redis系列（一）--安装、helloworld以及读懂配置文件","如何用Redis做LRU-Cache","Redis-key过期处理策略","\u002F折腾\u002F20180714","2018-07-14")));