__NUXT_JSONP__("/view/java/20200518/Java引用类型", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x){return {data:[{siteConfig:{siteName:o,siteHost:"https:\u002F\u002Fcellargalaxy.github.io",basePath:"\u002Fblog-code\u002F",navs:[{text:"文章",url:"\u002Fblog-code\u002Fpage\u002F1\u002F"},{text:"归档",url:"\u002Fblog-code\u002Farchive\u002F0\u002F"},{text:"画画",url:"\u002Fblog-code\u002Fhtml\u002Fhua.html"},{text:"开源",url:"\u002Fblog-code\u002Fhttps:\u002Fgithub.com\u002Fcellargalaxy\u002Fblog-vue"}],pageSize:10,urlReplace:{"^/file/blog/code":"https:\u002F\u002Foracleamd1.dynv6.net\u002Ffile\u002Ffile\u002Fblog\u002Fcode"},backgroundImage:{duration:p,fade:1000,images:[{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FcofTzDQXitjeVZ6.jpg",description:q,type:e},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F25\u002FsfaRJ2lVeM3NDbE.jpg",description:q,type:e},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F26\u002FKybiTdftam5Su7x.jpg",description:"青春猪头-双葉理央",type:e},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F09\u002F08\u002FxdX73nfs24qgOYk.jpg",description:"京吹-明日香,久美子",type:e},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F14\u002FMAiruNcEFW2HYtg.jpg",description:"终将成为你-七海灯子,小糸侑",type:e},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F05\u002FEojdAxTDJsFpbPw.jpg",description:"玉子市场-北白川玉子",type:e},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F31\u002FAXxwJDRS9fmN2uU.jpg",description:"fate_hf-弓道馆",type:e},{url:"https:\u002F\u002Fi.loli.net\u002F2020\u002F02\u002F01\u002FaHhVObpJus6dnM4.jpg",description:"fate_hf-樱花树",type:e}]}},homeConfig:{brandInterval:p,brands:[{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F21\u002FmMEAnwY5XPC2pFb.jpg",title:"日常",texts:["我们所度过的每个平凡的日常，也许就是连续不断发生的奇迹。","日々、私たちが過ごしている日常は、実は奇跡の連続なのかもしれない。"]},{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F04\u002F19\u002FH1MmXb9xPcYEhT2.jpg",title:"昨日之歌",texts:["时间梭梭箭如飞，人道漫漫步蹒跚","人間そんな変わるもんじゃないのに、月日ばっかどんどん過ぎて"]}],navs:[{text:"Github",url:"https:\u002F\u002Fgithub.com\u002Fcellargalaxy\u002F"}]},pageFootConfig:{lines:[[{text:"Copyright © 2017-? ."},{text:"备案？不存在的"},{text:"Powered by Nuxt.js & Github"}]]},buildTime:new Date(1684676168623),siteName:o,file:{slug:r,description:m,createdAt:s,updatedAt:s,toc:[],body:{type:t,children:[{type:b,tag:d,props:{},children:[{type:a,value:m}]},{type:a,value:c},{type:a,value:c},{type:b,tag:f,props:{id:u},children:[{type:b,tag:g,props:{ariaHidden:h,href:"#%E5%BC%BA%E5%BC%95%E7%94%A8",tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:u}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"形如"},{type:b,tag:n,props:{},children:[{type:a,value:"Object object = new Object();"}]},{type:a,value:"就是强引用。只有强引用还存在，虚拟机就不会回收这个对象。\n就是内存不够，也另可报OutOfMemoryError异常。直到一个对象没有强引用，虚拟机才会认为这个对象是可回收的。"}]},{type:a,value:c},{type:b,tag:f,props:{id:"软引用softreference"},children:[{type:b,tag:g,props:{ariaHidden:h,href:"#%E8%BD%AF%E5%BC%95%E7%94%A8softreference",tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:"软引用（SoftReference）"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"软引用对象，虚拟机是认为可回收的，但是只有虚拟机认为内存不够的时候才会回收。\n因此在报内存溢出以前，虚拟机是已经回收了全部软引用了。内存充足时虚拟机倾向于保留对象在内存里。\n因此软引用适合于做一些本地缓存。"}]},{type:a,value:c},{type:b,tag:f,props:{id:"弱引用weakreference"},children:[{type:b,tag:g,props:{ariaHidden:h,href:"#%E5%BC%B1%E5%BC%95%E7%94%A8weakreference",tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:"弱引用（WeakReference）"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"弱引用对象，虚拟机认为是可回收的，并且在GC时发现有弱引用对象就会回收。"}]},{type:a,value:c},{type:b,tag:f,props:{id:v},children:[{type:b,tag:g,props:{ariaHidden:h,href:"#%E8%99%9A%E5%BC%95%E7%94%A8",tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:v}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"虚引用对象，虚拟机认为这个对象跟没有引用一样，会在GC时进行回收。\n不同于软引用和弱引用，虚引用通过get方法获取对象永远为null。\n虚引用的作用仅仅是在对象在执行finalize方法之后，用户程序获知并可以做某些事情的机制。\n例如可以用来监控对象的回收。"}]},{type:a,value:c},{type:b,tag:f,props:{id:"引用队列referencequeue"},children:[{type:b,tag:g,props:{ariaHidden:h,href:"#%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97referencequeue",tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:"引用队列（ReferenceQueue）"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"如果给软引用、弱引用和虚引用添加一个引用队列的话，在引用对象被回收后，虚拟机会将引用加入到这个队列里，用户程序可以在这个队列里查找已经被回收的对象的引用。\n当然更加直接可以通过get方法判断对象是否已经被回收。虽然引用对象非强引用，但是引用本身是强引用，便于我们在需要时把引用设为null（如在引用数组里，如ThreadLocal）。"}]},{type:a,value:c},{type:b,tag:f,props:{id:"gc的重新标记最终标记"},children:[{type:b,tag:g,props:{ariaHidden:h,href:"#gc%E7%9A%84%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%E6%9C%80%E7%BB%88%E6%A0%87%E8%AE%B0",tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:"GC的重新标记\u002F最终标记"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"为什么CMS和G1在并发标记之后需要重新标记\u002F最终标记。所谓的在并发标记，用户程序还在执行会导致对象引用状态改变的其中一种情况就是。\n例如在并发标记一开始标记了一个弱引用对象需要被回收，但是之后用户程序从弱引用里取出对象变成了强引用。\n这就导致需要再进行一次STW的重新标记，检查那些被标记为需要回收的对象有没有复活。\n不过这个有个没想懂的问题，CMS在清除的时候是与用户线程并发的，这时候不也会有取出对象变强引用，但却被回收的问题吗？"}]},{type:a,value:c},{type:b,tag:f,props:{id:"threadlocal"},children:[{type:b,tag:g,props:{ariaHidden:h,href:"#threadlocal",tabIndex:i},children:[{type:b,tag:j,props:{className:[k,l]},children:[]}]},{type:a,value:"ThreadLocal"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"每个线程都有一个ThreadLocalMap对象，这个map的key是ThreadLocal，value是我们要保存的数据。"},{type:b,tag:n,props:{},children:[{type:a,value:"Thread-\u003EThreadLocalMap\u003CThreadLocal,T\u003E"}]},{type:a,value:"。\n例如get对象时，ThreadLocal里通过currentThread获取ThreadLocalMap对象，再通过"},{type:b,tag:n,props:{},children:[{type:a,value:"map.get(this)"}]},{type:a,value:"获取对象。\n但ThreadLocalMap对ThreadLocal的引用是弱引用，这样当ThreadLocal的强引用都消失时，GC就能回收ThreadLocal对象。\n剩下key是null的value，但是ThreadLocalMap对value的引用强引用，value并不会被GC回收。久而久之就会内存溢出。\n所以在其他ThreadLocal调用get、set、remove方法时，都可能会检查清理ThreadLocalMap中key为null的value。\n最后，为什么不把value也弄成弱引用呢？value只被ThreadLocalMap弱引用就被回收了呀，转个头ThreadLocal来取值发现value是null的？"}]}]},excerpt:{type:t,children:[{type:b,tag:d,props:{},children:[{type:a,value:m}]}]},dir:w,path:"\u002Fjava\u002F20200518\u002FJava引用类型",extension:".md",title:r,url:"\u002Fblog-code\u002Fview\u002Fjava\u002F20200518\u002FJava引用类型\u002F",createAt:new Date(1589760000000),updateAt:new Date(1589760000000),attributes:[{name:"createAt",value:x},{name:"updateAt",value:x},{name:"sort",value:w,url:"\u002Fblog-code\u002Fpage\u002Fjava\u002F20200518\u002F1\u002F"}]}}],fetch:{},mutations:void 0}}("text","element","\n","p","wide","h1","a","true",-1,"span","icon","icon-link","java除了基本类型以外，其余的都是引用类型。\n而java的引用类型有四种：强引用，软引用，弱引用和虚引用。\n除了强引用外，其余的引用都是抽象类Reference的子类。","code","无名の窝",10000,"青春猪头-牧之原翔子-江之岛","Java引用类型","2020-05-18T00:00:00.000Z","root","强引用","虚引用","\u002Fjava\u002F20200518","2020-05-18")));