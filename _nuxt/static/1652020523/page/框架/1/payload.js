__NUXT_JSONP__("/page/%E6%A1%86%E6%9E%B6/1", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag){r.type=d;r.children=[{type:b,tag:j,props:{},children:[{type:a,value:"Protocol Buffers(简称Protobuf) 是Google的一个序列化框架，与开发语言、平台无关。"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"支持Java、Python、C++、Go、JavaNano、Ruby、C#。"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"Portobuf的序列化体积比XML和JSON小，并且序列化和反序列化的速度更快。"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"使用Portobuf需要先安装Portobuf的命令行工具protoc，编写protobuf文件，使用protoc生成对应语言的代码。"}]}];w.type=d;w.children=[];B.type=d;B.children=[];G.type=d;G.children=[];L.type=d;L.children=[];Q.type=d;Q.children=[];V.type=d;V.children=[];_.type=d;_.children=[{type:b,tag:j,props:{},children:[{type:a,value:"最近终于终于啃完翟永超的《Spring Cloud微服务实战》。看完之后，对于这些牛逼的东西，我只能说我终于知道Spring Cloud是想干嘛了（叹气。jpg）。对此总结一下。"}]},{type:a,value:c},{type:b,tag:j,props:{},children:[{type:a,value:"实施Spring Cloud，即想通过把原本单独的大系统，拆分为多个的微服务，以达到系统解耦的目的。但为了依旧提供完整的服务，各个微服务仍然存在着业务依赖。而这些业务依赖则通过rpc等方式进行调用。因此微服务里存在着两个根本角色：服务提供者和服务消费者。当然，对于某一个微服务而言，他自己可以既是服务提供者也是服务消费者，因为他即为其他微服务提供服务，也使用其他微服务的服务。然而这么做问题会出现一大堆，Spring Cloud就是为了解决这些问题而开发或者封装其他工具诞生的。这里先罗列几个这些问题："}]},{type:a,value:c},{type:b,tag:"ol",props:{},children:[{type:a,value:c},{type:b,tag:l,props:{},children:[{type:a,value:"作为服务消费者，怎么知道服务提供者在哪"}]},{type:a,value:c},{type:b,tag:l,props:{},children:[{type:a,value:"作为服务消费者，怎样调用服务提供者的服务"}]},{type:a,value:c},{type:b,tag:l,props:{},children:[{type:a,value:"作为服务消费者，万一服务提供者挂了该怎么办。不可能晾着其他请求一直等这位服务提供者恢复吧！？"}]},{type:a,value:c},{type:b,tag:l,props:{},children:[{type:a,value:"拆分后，微服务数量众多，又各自为政。接口自行变更，管理混乱，怎么办？"}]},{type:a,value:c},{type:b,tag:l,props:{},children:[{type:a,value:"拆分后，微服务数量众多，又各自为政。微服务之间怎样互通消息？"}]},{type:a,value:c},{type:b,tag:l,props:{},children:[{type:a,value:"拆分后，微服务数量众多，又各自为政。如果要修改配置，岂不是要一改就要改好几十甚至上百台机？"}]},{type:a,value:c}]}];ad.type=d;ad.children=[{type:b,tag:j,props:{},children:[{type:a,value:ac}]}];ag.type=d;ag.children=[];return {data:[{navbarConfig:{brandText:"无名の窝",brandUrl:"\u002Fblog-code\u002F",navs:[{text:"文章",url:"\u002Fblog-code\u002Fpage\u002F1\u002F"},{text:"归档",url:"\u002Fblog-code\u002Farchive\u002F0\u002F"},{text:"画画",url:"\u002Fblog-code\u002Fhtml\u002Fhua.html"},{text:"开源",url:"\u002Fblog-code\u002Fhttps:\u002Fgithub.com\u002Fcellargalaxy\u002Fblog-vue"}]},homeConfig:{brandInterval:10000,brands:[{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F21\u002FmMEAnwY5XPC2pFb.jpg",title:"日常",texts:["我们所度过的每个平凡的日常，也许就是连续不断发生的奇迹。","日々、私たちが過ごしている日常は、実は奇跡の連続なのかもしれない。"]},{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F04\u002F19\u002FH1MmXb9xPcYEhT2.jpg",title:"昨日之歌",texts:["时间梭梭箭如飞，人道漫漫步蹒跚","人間そんな変わるもんじゃないのに、月日ばっかどんどん過ぎて"]}],navs:[{text:"Github",url:"https:\u002F\u002Fgithub.com\u002Fcellargalaxy\u002F"}]},pageFootConfig:{lines:[[{text:"Copyright © 2017-? ."},{text:"备案？不存在的"},{text:"Powered by Nuxt.js & Github"}]]},buildTime:new Date(1652020606338),basePath:"\u002Fpage",folderPath:"框架",pageSize:10,total:21,currentPage:1,files:[{slug:p,description:"Protocol Buffers(简称Protobuf) 是Google的一个序列化框架，与开发语言、平台无关。\n支持Java、Python、C++、Go、JavaNano、Ruby、C#。\nPortobuf的序列化体积比XML和JSON小，并且序列化和反序列化的速度更快。\n使用Portobuf需要先安装Portobuf的命令行工具protoc，编写protobuf文件，使用protoc生成对应语言的代码。",createdAt:q,updatedAt:q,toc:[],body:r,excerpt:r,dir:s,path:"\u002F框架\u002F20210419\u002Fgolang使用protobuf笔记",extension:e,title:p,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20210419\u002Fgolang使用protobuf笔记",createAt:new Date(1618790400000),updateAt:new Date(1618790400000),attributes:[{name:f,value:t},{name:g,value:t},{name:h,value:s,url:"\u002Fblog-code\u002Fpage\u002F框架\u002F20210419\u002F1\u002F"}]},{slug:u,description:k,createdAt:v,updatedAt:v,toc:[],body:w,excerpt:w,dir:x,path:"\u002F框架\u002F20200714\u002FSpring Bean总结",extension:e,title:u,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20200714\u002FSpring Bean总结",createAt:new Date(1594684800000),updateAt:new Date(1594684800000),attributes:[{name:f,value:y},{name:g,value:y},{name:h,value:x,url:"\u002Fblog-code\u002Fpage\u002F框架\u002F20200714\u002F1\u002F"}]},{slug:z,description:k,createdAt:A,updatedAt:A,toc:[{id:"required",depth:i,text:"REQUIRED"},{id:"nested",depth:i,text:"NESTED"},{id:"requires_new",depth:i,text:"REQUIRES_NEW"},{id:"mandatory",depth:i,text:"MANDATORY"},{id:"supports",depth:i,text:"SUPPORTS"},{id:"not_supported",depth:i,text:"NOT_SUPPORTED"},{id:"never",depth:i,text:"NEVER"}],body:B,excerpt:B,dir:C,path:"\u002F框架\u002F20200707\u002FSpring事务总结",extension:e,title:z,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20200707\u002FSpring事务总结",createAt:new Date(1594080000000),updateAt:new Date(1594080000000),attributes:[{name:f,value:D},{name:g,value:D},{name:h,value:C,url:"\u002Fblog-code\u002Fpage\u002F框架\u002F20200707\u002F1\u002F"}]},{slug:E,description:k,createdAt:F,updatedAt:F,toc:[],body:G,excerpt:G,dir:H,path:"\u002F框架\u002F20200602\u002FTaf框架",extension:e,title:E,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20200602\u002FTaf框架",createAt:new Date(1591056000000),updateAt:new Date(1591056000000),attributes:[{name:f,value:I},{name:g,value:I},{name:h,value:H,url:"\u002Fblog-code\u002Fpage\u002F框架\u002F20200602\u002F1\u002F"}]},{slug:J,description:k,createdAt:K,updatedAt:K,toc:[],body:L,excerpt:L,dir:M,path:"\u002F框架\u002F20200319\u002FSpringBoot的配置文件",extension:e,title:J,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20200319\u002FSpringBoot的配置文件",createAt:new Date(1584576000000),updateAt:new Date(1584576000000),attributes:[{name:f,value:N},{name:g,value:N},{name:h,value:M,url:"\u002Fblog-code\u002Fpage\u002F框架\u002F20200319\u002F1\u002F"}]},{slug:O,description:k,createdAt:P,updatedAt:P,toc:[],body:Q,excerpt:Q,dir:R,path:"\u002F框架\u002F20190828\u002F创建自定义starter包",extension:e,title:O,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20190828\u002F创建自定义starter包",createAt:new Date(1566950400000),updateAt:new Date(1566950400000),attributes:[{name:f,value:S},{name:g,value:S},{name:h,value:R,url:"\u002Fblog-code\u002Fpage\u002F框架\u002F20190828\u002F1\u002F"}]},{slug:T,description:k,createdAt:U,updatedAt:U,toc:[],body:V,excerpt:V,dir:W,path:"\u002F框架\u002F20190215\u002FSpring Boot自动配置",extension:e,title:T,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20190215\u002FSpring Boot自动配置",createAt:new Date(1550188800000),updateAt:new Date(1550188800000),attributes:[{name:f,value:X},{name:g,value:X},{name:h,value:W,url:"\u002Fblog-code\u002Fpage\u002F框架\u002F20190215\u002F1\u002F"}]},{slug:Y,description:"最近终于终于啃完翟永超的《Spring Cloud微服务实战》。看完之后，对于这些牛逼的东西，我只能说我终于知道Spring Cloud是想干嘛了（叹气。jpg）。对此总结一下。\n实施Spring Cloud，即想通过把原本单独的大系统，拆分为多个的微服务，以达到系统解耦的目的。但为了依旧提供完整的服务，各个微服务仍然存在着业务依赖。而这些业务依赖则通过rpc等方式进行调用。因此微服务里存在着两个根本角色：服务提供者和服务消费者。当然，对于某一个微服务而言，他自己可以既是服务提供者也是服务消费者，因为他即为其他微服务提供服务，也使用其他微服务的服务。然而这么做问题会出现一大堆，Spring Cloud就是为了解决这些问题而开发或者封装其他工具诞生的。这里先罗列几个这些问题：\n\n作为服务消费者，怎么知道服务提供者在哪\n作为服务消费者，怎样调用服务提供者的服务\n作为服务消费者，万一服务提供者挂了该怎么办。不可能晾着其他请求一直等这位服务提供者恢复吧！？\n拆分后，微服务数量众多，又各自为政。接口自行变更，管理混乱，怎么办？\n拆分后，微服务数量众多，又各自为政。微服务之间怎样互通消息？\n拆分后，微服务数量众多，又各自为政。如果要修改配置，岂不是要一改就要改好几十甚至上百台机？\n",createdAt:Z,updatedAt:Z,toc:[],body:_,excerpt:_,dir:$,path:"\u002F框架\u002F20181216\u002FSpring Cloud",extension:e,title:Y,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20181216\u002FSpring Cloud",createAt:new Date(1544918400000),updateAt:new Date(1544918400000),attributes:[{name:f,value:aa},{name:g,value:aa},{name:h,value:$,url:"\u002Fblog-code\u002Fpage\u002F框架\u002F20181216\u002F1\u002F"}]},{slug:ab,description:ac,createdAt:m,updatedAt:m,toc:[],body:ad,excerpt:ad,dir:n,path:"\u002F框架\u002F20181024\u002FQuartz集群原理及源码分析",extension:e,title:ab,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20181024\u002FQuartz集群原理及源码分析",createAt:new Date(1540339200000),updateAt:new Date(1540339200000),attributes:[{name:f,value:o},{name:g,value:o},{name:h,value:n,url:ae}]},{slug:af,description:k,createdAt:m,updatedAt:m,toc:[{id:"job与jobdetail",depth:i,text:"Job与JobDetail"},{id:"trigger",depth:i,text:"Trigger"},{id:"scheduler",depth:i,text:"Scheduler"}],body:ag,excerpt:ag,dir:n,path:"\u002F框架\u002F20181024\u002FQuartz框架的使用",extension:e,title:af,url:"\u002Fblog-code\u002Fview\u002F框架\u002F20181024\u002FQuartz框架的使用",createAt:new Date(1540339200000),updateAt:new Date(1540339200000),attributes:[{name:f,value:o},{name:g,value:o},{name:h,value:n,url:ae}]}]}],fetch:{},mutations:void 0}}("text","element","\n","root",".md","createAt","updateAt","sort",2,"p","","li","2018-10-24T00:00:00.000Z","\u002F框架\u002F20181024","2018-10-24","golang使用protobuf笔记","2021-04-19T00:00:00.000Z",{},"\u002F框架\u002F20210419","2021-04-19","Spring Bean总结","2020-07-14T00:00:00.000Z",{},"\u002F框架\u002F20200714","2020-07-14","Spring事务总结","2020-07-07T00:00:00.000Z",{},"\u002F框架\u002F20200707","2020-07-07","Taf框架","2020-06-02T00:00:00.000Z",{},"\u002F框架\u002F20200602","2020-06-02","SpringBoot的配置文件","2020-03-19T00:00:00.000Z",{},"\u002F框架\u002F20200319","2020-03-19","创建自定义starter包","2019-08-28T00:00:00.000Z",{},"\u002F框架\u002F20190828","2019-08-28","Spring Boot自动配置","2019-02-15T00:00:00.000Z",{},"\u002F框架\u002F20190215","2019-02-15","Spring Cloud","2018-12-16T00:00:00.000Z",{},"\u002F框架\u002F20181216","2018-12-16","Quartz集群原理及源码分析","我们需要Quartz框架执行任务，就需要告诉Quartz所需的JobDetail和Trigger。在单机里，Quartz会把JobDetail和Trigger保存在内存里，如果重启，JobDetail和Trigger的数据都会全部丢失（虽然会在代码里重新添加）。显然，需要集群执行，把JobDetail和Trigger保存在内存里是没有办法在各个节点之间进行同步的，而Quartz利用数据库的锁来进行实现。",{},"\u002Fblog-code\u002Fpage\u002F框架\u002F20181024\u002F1\u002F","Quartz框架的使用",{})));