__NUXT_JSONP__("/view/%E5%8D%8F%E8%AE%AE/20180802/JSONP%E5%92%8CCORS%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_){return {data:[{navbarConfig:{brandText:H,brandUrl:"\u002Fblog-code\u002F",navs:[{text:"文章",url:"\u002Fblog-code\u002Fpage\u002F1\u002F"},{text:"归档",url:"\u002Fblog-code\u002Farchive\u002F0\u002F"},{text:"画画",url:"\u002Fblog-code\u002Fhtml\u002Fhua.html"},{text:"开源",url:"\u002Fblog-code\u002Fhttps:\u002Fgithub.com\u002Fcellargalaxy\u002Fblog-vue"}]},homeConfig:{brandInterval:10000,brands:[{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F21\u002FmMEAnwY5XPC2pFb.jpg",title:"日常",texts:["我们所度过的每个平凡的日常，也许就是连续不断发生的奇迹。","日々、私たちが過ごしている日常は、実は奇跡の連続なのかもしれない。"]},{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F04\u002F19\u002FH1MmXb9xPcYEhT2.jpg",title:"昨日之歌",texts:["时间梭梭箭如飞，人道漫漫步蹒跚","人間そんな変わるもんじゃないのに、月日ばっかどんどん過ぎて"]}],navs:[{text:"Github",url:"https:\u002F\u002Fgithub.com\u002Fcellargalaxy\u002F"}]},pageFootConfig:{lines:[[{text:"Copyright © 2017-? ."},{text:"备案？不存在的"},{text:"Powered by Nuxt.js & Github"}]]},buildTime:new Date(1652020531104),siteName:H,file:{slug:I,description:"何为域\n这里的域指的并不是域名，而是协议、主机地址和端口的唯一组合，即协议，主机地址和端口其中一个不一样那就是另外一个域了。\n跨域问题为何而来\n浏览器为了安全，避免网页被嵌入恶意代码，限制来源于某个域的脚本只能向其来源的域发起ajax请求，并且脚本也无法获取别的域的cookie，DOM等资源，这个叫同源策略。例如我在http:\u002F\u002Fwww.alipay.com\u002F里嵌入了个检测你支付宝密码的脚本，发现你输入密码，就把你的密码发送到我的域名下，但由于我的域名跟阿里的域名不在同一个域里面，这样子偷偷发送密码的请求就会被浏览器拦截住。\n接下来以来源于a.com域（简称a域）的脚本向b.com（简称b域）发起请求作为情景来解释",createdAt:J,updatedAt:J,toc:[{id:u,depth:n,text:u},{id:v,depth:n,text:v},{id:w,depth:n,text:w},{id:x,depth:n,text:x},{id:y,depth:n,text:y},{id:z,depth:n,text:z}],body:{type:K,children:[{type:b,tag:l,props:{id:A},children:[{type:b,tag:f,props:{href:L,ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:A}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:M}]},{type:a,value:c},{type:b,tag:l,props:{id:B},children:[{type:b,tag:f,props:{href:N,ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:O},{type:b,tag:d,props:{},children:[{type:a,value:P}]},{type:a,value:Q}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:R}]},{type:a,value:c},{type:a,value:c},{type:b,tag:l,props:{id:"jsonp"},children:[{type:b,tag:f,props:{href:"#jsonp",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:"JSONP"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"同源策略只是限制了a域的脚本不能向b域域发起ajax请求，但是实际上，a域的html还是可以加载其他域的资源。例如"},{type:b,tag:d,props:{},children:[{type:a,value:S}]},{type:a,value:"标签等，就可以加载他域资源。因此，利用这个“漏洞”，a域的脚本往dom里插入一个"},{type:b,tag:d,props:{},children:[{type:a,value:S}]},{type:a,value:"标签，标签的src的链接是b域的，url还需要带上一个回调函数的名字，例如"},{type:b,tag:d,props:{},children:[{type:a,value:"http:\u002F\u002Fb.com?callback=handleCallback"}]},{type:a,value:"，这样b域的服务器返回一个js文件，这个js包含参数指定的那个回调函数的方法，方法里包含的不是业务逻辑，而是数据。所以等这个js文件加载完，a域的js调用一下这个函数，就能获取到来源于b域的数据。这种办法就叫做jsonp（不知道跟json有啥关系）。但显然，这种方法只能使用get方法，有很大的局限性。"}]},{type:a,value:c},{type:b,tag:l,props:{id:"cors"},children:[{type:b,tag:f,props:{href:"#cors",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:"CORS"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"CORS能解决跨域请求问题，其全称为跨域资源共享（Cross-origin resource sharing），是W3C推荐的解决跨域问题的一个标准。CORS需要服务器和浏览器同时支持才行，而浏览器几乎都是已经支持的。浏览器对跨域的请求分了两类，简单请求和非简单请求，对这两种请求浏览器和服务器的处理策略都不一样。"}]},{type:a,value:c},{type:b,tag:l,props:{id:T},children:[{type:b,tag:f,props:{href:"#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:T}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"简单请求的标准是："}]},{type:a,value:c},{type:b,tag:"ol",props:{},children:[{type:a,value:c},{type:b,tag:C,props:{},children:[{type:a,value:"请求方法是"},{type:b,tag:d,props:{},children:[{type:a,value:"HEAD"}]},{type:a,value:m},{type:b,tag:d,props:{},children:[{type:a,value:"GET"}]},{type:a,value:"和"},{type:b,tag:d,props:{},children:[{type:a,value:"POST"}]},{type:a,value:"其中一种"}]},{type:a,value:c},{type:b,tag:C,props:{},children:[{type:a,value:"头信息不超出"},{type:b,tag:d,props:{},children:[{type:a,value:"Accept"}]},{type:a,value:m},{type:b,tag:d,props:{},children:[{type:a,value:"Accept-Language"}]},{type:a,value:m},{type:b,tag:d,props:{},children:[{type:a,value:"Content-Language"}]},{type:a,value:m},{type:b,tag:d,props:{},children:[{type:a,value:"Last-Event-ID"}]},{type:a,value:m},{type:b,tag:d,props:{},children:[{type:a,value:U}]},{type:a,value:"这几个字段"}]},{type:a,value:c},{type:b,tag:C,props:{},children:[{type:a,value:"头"},{type:b,tag:d,props:{},children:[{type:a,value:U}]},{type:a,value:"的值只能取"},{type:b,tag:d,props:{},children:[{type:a,value:"application\u002Fx-www-form-urlencoded"}]},{type:a,value:m},{type:b,tag:d,props:{},children:[{type:a,value:"multipart\u002Fform-data"}]},{type:a,value:m},{type:b,tag:d,props:{},children:[{type:a,value:"text\u002Fplain"}]},{type:a,value:"之一"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:o,props:{id:u},children:[{type:b,tag:f,props:{href:"#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%B7%E6%B1%82",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:u}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"对于简单请求。浏览器会在请求头里加个Origin字段，用来表明这次请求是来自于a域的js发起的，包含协议、主机地址和端口"}]},{type:a,value:c},{type:b,tag:p,props:{className:[q]},children:[{type:b,tag:r,props:{className:[s,t]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"GET \u002Fcors HTTP\u002F1.1\nOrigin: http:\u002F\u002Fa.com\nHost: b.com...\n"}]}]}]},{type:a,value:c},{type:b,tag:o,props:{id:v},children:[{type:b,tag:f,props:{href:"#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E7%9A%84%E5%93%8D%E5%BA%94",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:v}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"服务器收到这个请求之后，发现有Origin字段，就会判断接不接受来自于a域的js发起的这个请求。如果服务器接受这次请求，会在正常、普通、200的响应上加上几个头用来标识自己接受这个跨域请求，添加的头为："}]},{type:a,value:c},{type:b,tag:p,props:{className:[q]},children:[{type:b,tag:r,props:{className:[s,t]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"Access-Control-Allow-Origin: http:\u002F\u002Fa.com\n必须，表示此域的跨域访问，*号代表接受任何的域进行跨域访问，但只能指定一个域\n\nAccess-Control-Allow-Credentials: true\n可选，表示服务器是否接收a域的cookie，只能取值为true，如果想false，删掉这个字段就行\n\nAccess-Control-Expose-Headers: X-Custom-Header\n可选，浏览器接收到响应后，默认XMLHttpRequest对象的getResponseHeader()方法只能拿到Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma六个字段。如果想他能获取到非默认的X-Custom-Header字段，就要添加在这里\n"}]}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果不接受，则返回一个正常、普通、200的响应。浏览器发现响应没有响应没有上面这些头字段，就知道服务器不接受这次请求，就会报错了。\nAccess-Control-Allow-Credentials字段只是表示服务器能接收cookie，但是浏览器不一定会发送，为了指明浏览器跨域发送cookie，可以设置"},{type:b,tag:d,props:{},children:[{type:a,value:"new XMLHttpRequest().withCredentials=true"}]},{type:a,value:"。"}]},{type:a,value:c},{type:b,tag:l,props:{id:V},children:[{type:b,tag:f,props:{href:"#%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:V}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"不是简单请求的请求都是非简单请求了，例如要使用put，delete方法，或者Content-Type字段为application\u002Fjson。对于非简单请求，浏览器会先发送一个请求，叫做预检请求，这个预检请求的目的是向服务器确定能否发送这个跨域请求，因此这个请求由浏览器控制，是不在页面代码控制范围里的。浏览器得到服务器确认之后才会发起实际的请求。"}]},{type:a,value:c},{type:b,tag:o,props:{id:w},children:[{type:b,tag:f,props:{href:"#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%B7%E6%B1%82",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"预检请求是个OPTIONS请求，他会在头里带上几个字段来询问服务器是否接受这种跨域请求"}]},{type:a,value:c},{type:b,tag:p,props:{className:[q]},children:[{type:b,tag:r,props:{className:[s,t]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"OPTIONS \u002Fcors HTTP\u002F1.1\nOrigin: http:\u002F\u002Fa.com    来自于这个域的脚本\nAccess-Control-Request-Method: PUT    想向你发起一个put请求\nAccess-Control-Request-Headers: X-Custom-Header    还会带上这些头信息\nHost: b.com\n"}]}]}]},{type:a,value:c},{type:b,tag:o,props:{id:x},children:[{type:b,tag:f,props:{href:"#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9B%9E%E5%BA%94",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:x}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果浏览器接受这种跨域请求，就会加几个头字段来表示自己接受"}]},{type:a,value:c},{type:b,tag:p,props:{className:[q]},children:[{type:b,tag:r,props:{className:[s,t]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"HTTP\u002F1.1 200 OK\nAccess-Control-Allow-Origin: http:\u002F\u002Fa.com    我接受来自于a域的跨域请求，*表示接受任意域\nAccess-Control-Allow-Methods: GET, POST, PUT    请求的方法我接受这些\nAccess-Control-Allow-Headers: X-Custom-Header    请求的头也可以带上这些\nAccess-Control-Allow-Credentials: true    这个跨域我接受cookie\nAccess-Control-Max-Age: 1728000    并且这之后这么久之内我都是同样的答复的\n"}]}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"如果浏览器拒绝，就会返回一个正常、普通、200的响应，浏览器发现没有上门这些头字段，就会知道服务器拒绝了这个跨域请求。"}]},{type:a,value:c},{type:b,tag:o,props:{id:y},children:[{type:b,tag:f,props:{href:"#%E5%AE%9E%E9%99%85%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%B7%E6%B1%82",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:y}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"浏览器在预检请求里知道服务器接受跨域请求之后，就会发起实际的请求。在实际请求的请求里，依然会加上Origin来表示是哪个域的脚本发起这次请求的"}]},{type:a,value:c},{type:b,tag:p,props:{className:[q]},children:[{type:b,tag:r,props:{className:[s,t]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"PUT \u002Fcors HTTP\u002F1.1\nOrigin: http:\u002F\u002Fa.com\nHost: b.com\nX-Custom-Header: value\n"}]}]}]},{type:a,value:c},{type:b,tag:o,props:{id:z},children:[{type:b,tag:f,props:{href:"#%E5%AE%9E%E9%99%85%E8%AF%B7%E6%B1%82%E7%9A%84%E5%93%8D%E5%BA%94",ariaHidden:g,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:z}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"浏览器也会加上Access-Control-Allow-Origin来表示自己接受那些域的跨域访问"}]},{type:a,value:c},{type:b,tag:p,props:{className:[q]},children:[{type:b,tag:r,props:{className:[s,t]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"HTTP\u002F1.1 200 OK\nAccess-Control-Allow-Origin: http:\u002F\u002Fa.com\n"}]}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"参考文献："}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{href:"http:\u002F\u002Fwww.ruanyifeng.com\u002Fblog\u002F2016\u002F04\u002Fcors.html",rel:[D,E,F],target:G,title:W},children:[{type:a,value:W}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fwww.jianshu.com\u002Fp\u002F52bf8f5b8432",rel:[D,E,F],target:G,title:X},children:[{type:a,value:X}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{href:"https:\u002F\u002Fisudox.com\u002F2016\u002F09\u002F24\u002Fcross-site-jsonp-and-cors\u002F",rel:[D,E,F],target:G,title:Y},children:[{type:a,value:Y}]}]}]},excerpt:{type:K,children:[{type:b,tag:l,props:{id:A},children:[{type:b,tag:f,props:{ariaHidden:g,href:L,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:A}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:M}]},{type:a,value:c},{type:b,tag:l,props:{id:B},children:[{type:b,tag:f,props:{ariaHidden:g,href:N,tabIndex:h},children:[{type:b,tag:i,props:{className:[j,k]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:O},{type:b,tag:d,props:{},children:[{type:a,value:P}]},{type:a,value:Q}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:R}]}]},dir:Z,path:"\u002F协议\u002F20180802\u002FJSONP和CORS的跨域请求",extension:".md",title:I,url:"\u002Fblog-code\u002Fview\u002F协议\u002F20180802\u002FJSONP和CORS的跨域请求",createAt:new Date(1533168000000),updateAt:new Date(1533168000000),attributes:[{name:"createAt",value:_},{name:"updateAt",value:_},{name:"sort",value:Z,url:"\u002Fblog-code\u002Fpage\u002F协议\u002F20180802\u002F1\u002F"}]}}],fetch:{},mutations:void 0}}("text","element","\n","code","p","a","true",-1,"span","icon","icon-link","h1","、",2,"h2","div","nuxt-content-highlight","pre","language-text","line-numbers","简单请求的请求","简单请求的响应","预检请求的请求","预检请求的回应","实际请求的请求","实际请求的响应","何为域","跨域问题为何而来","li","nofollow","noopener","noreferrer","_blank","无名の窝","JSONP和CORS的跨域请求","2018-08-02T00:00:00.000Z","root","#%E4%BD%95%E4%B8%BA%E5%9F%9F","这里的域指的并不是域名，而是协议、主机地址和端口的唯一组合，即协议，主机地址和端口其中一个不一样那就是另外一个域了。","#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BD%95%E8%80%8C%E6%9D%A5","浏览器为了安全，避免网页被嵌入恶意代码，限制来源于某个域的脚本只能向其来源的域发起ajax请求，并且脚本也无法获取别的域的cookie，DOM等资源，这个叫同源策略。例如我在","http:\u002F\u002Fwww.alipay.com\u002F","里嵌入了个检测你支付宝密码的脚本，发现你输入密码，就把你的密码发送到我的域名下，但由于我的域名跟阿里的域名不在同一个域里面，这样子偷偷发送密码的请求就会被浏览器拦截住。","接下来以来源于a.com域（简称a域）的脚本向b.com（简称b域）发起请求作为情景来解释","\u003Cscript\u003E","简单请求","Content-Type","非简单请求","跨域资源共享 CORS 详解","跨域资源共享CORS总结","跨域请求之 JSONP 和 CORS","\u002F协议\u002F20180802","2018-08-02")));