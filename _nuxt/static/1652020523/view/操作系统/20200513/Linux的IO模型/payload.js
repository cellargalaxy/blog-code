__NUXT_JSONP__("/view/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200513/Linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W){return {data:[{navbarConfig:{brandText:y,brandUrl:"\u002Fblog-code\u002F",navs:[{text:"文章",url:"\u002Fblog-code\u002Fpage\u002F1\u002F"},{text:"归档",url:"\u002Fblog-code\u002Farchive\u002F0\u002F"},{text:"画画",url:"\u002Fblog-code\u002Fhtml\u002Fhua.html"},{text:"开源",url:"\u002Fblog-code\u002Fhttps:\u002Fgithub.com\u002Fcellargalaxy\u002Fblog-vue"}]},homeConfig:{brandInterval:10000,brands:[{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F01\u002F21\u002FmMEAnwY5XPC2pFb.jpg",title:"日常",texts:["我们所度过的每个平凡的日常，也许就是连续不断发生的奇迹。","日々、私たちが過ごしている日常は、実は奇跡の連続なのかもしれない。"]},{imageUrl:"https:\u002F\u002Fi.loli.net\u002F2020\u002F04\u002F19\u002FH1MmXb9xPcYEhT2.jpg",title:"昨日之歌",texts:["时间梭梭箭如飞，人道漫漫步蹒跚","人間そんな変わるもんじゃないのに、月日ばっかどんどん過ぎて"]}],navs:[{text:"Github",url:"https:\u002F\u002Fgithub.com\u002Fcellargalaxy\u002F"}]},pageFootConfig:{lines:[[{text:"Copyright © 2017-? ."},{text:"备案？不存在的"},{text:"Powered by Nuxt.js & Github"}]]},buildTime:new Date(1652020531929),siteName:y,file:{slug:z,description:"本文主要是聊聊 Linux 中的五种 IO 模型的概括。",createdAt:A,updatedAt:A,toc:[],body:{type:B,children:[{type:a,tag:e,props:{},children:[{type:b,value:C},{type:a,tag:f,props:{href:D,rel:[q,r,s],target:t},children:[{type:b,value:E}]},{type:b,value:F}]},{type:b,value:c},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"对于32位的计算机，操作系统最多给每个进程分配4G的内存。针对linux而言，linux会把其中1G分配为内核空间，另外3G分配为用户空间。"}]},{type:b,value:c},{type:a,tag:G,props:{},children:[{type:b,value:c},{type:a,tag:m,props:{},children:[{type:b,value:"阻塞：进程被迫等待内核"}]},{type:b,value:c},{type:a,tag:m,props:{},children:[{type:b,value:"非阻塞：进程可以不等待内核"}]},{type:b,value:c},{type:a,tag:m,props:{},children:[{type:b,value:"同步：进程向内核发起调用"}]},{type:b,value:c},{type:a,tag:m,props:{},children:[{type:b,value:"异步：内核向进程发起调用"}]},{type:b,value:c}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"内核会先将数据写到内核空间的缓冲区里，之后内核才会将数据从内核空间拷贝到用户空间里，进程才能读取数据。所以进程有两个等待阶段。"}]},{type:b,value:c},{type:a,tag:"ol",props:{},children:[{type:b,value:c},{type:a,tag:m,props:{},children:[{type:b,value:"阶段一：等待数据从硬件写入内核空间（准备数据）"}]},{type:b,value:c},{type:a,tag:m,props:{},children:[{type:b,value:"阶段二：等待数据从内核空间写入到用户空间（拷贝数据）"}]},{type:b,value:c}]},{type:b,value:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{type:a,tag:H,props:{},children:[{type:a,tag:I,props:{},children:[{type:a,tag:n,props:{},children:[{type:a,tag:o,props:{},children:[]},{type:a,tag:o,props:{},children:[{type:b,value:"同步"}]},{type:a,tag:o,props:{},children:[{type:b,value:"异步"}]}]}]},{type:a,tag:J,props:{},children:[{type:a,tag:n,props:{},children:[{type:a,tag:d,props:{},children:[{type:b,value:p}]},{type:a,tag:d,props:{},children:[{type:b,value:"同步阻塞IO,多路复用IO"}]},{type:a,tag:d,props:{},children:[]}]},{type:a,tag:n,props:{},children:[{type:a,tag:d,props:{},children:[{type:b,value:"非阻塞"}]},{type:a,tag:d,props:{},children:[{type:b,value:K}]},{type:a,tag:d,props:{},children:[{type:b,value:L}]}]}]}]},{type:b,value:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{type:a,tag:H,props:{},children:[{type:a,tag:I,props:{},children:[{type:a,tag:n,props:{},children:[{type:a,tag:o,props:{},children:[]},{type:a,tag:o,props:{},children:[{type:b,value:"阶段一"}]},{type:a,tag:o,props:{},children:[{type:b,value:"阶段二"}]}]}]},{type:a,tag:J,props:{},children:[{type:a,tag:n,props:{},children:[{type:a,tag:d,props:{},children:[{type:b,value:"同步阻塞IO"}]},{type:a,tag:d,props:{},children:[{type:b,value:p}]},{type:a,tag:d,props:{},children:[{type:b,value:p}]}]},{type:a,tag:n,props:{},children:[{type:a,tag:d,props:{},children:[{type:b,value:K}]},{type:a,tag:d,props:{},children:[{type:b,value:"非阻塞,轮询"}]},{type:a,tag:d,props:{},children:[{type:b,value:p}]}]},{type:a,tag:n,props:{},children:[{type:a,tag:d,props:{},children:[{type:b,value:w}]},{type:a,tag:d,props:{},children:[{type:b,value:p}]},{type:a,tag:d,props:{},children:[{type:b,value:p}]}]},{type:a,tag:n,props:{},children:[{type:a,tag:d,props:{},children:[{type:b,value:L}]},{type:a,tag:d,props:{},children:[{type:b,value:M}]},{type:a,tag:d,props:{},children:[{type:b,value:M}]}]}]}]},{type:b,value:c},{type:a,tag:g,props:{id:"同步阻塞iobio"},children:[{type:a,tag:f,props:{href:"#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9Eiobio",ariaHidden:h,tabIndex:i},children:[{type:a,tag:j,props:{className:[k,l]},children:[]}]},{type:b,value:N}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"阻塞IO，进程发起read操作被阻塞，此时内核会开始准备数据，数据准备好了，再将数据从内核空间写入到用户空间，然后read操作才返回，进程解除阻塞状态。\n显然，这样子进程的大部分时间都在阻塞等待数据的准备和拷贝。\n"},{type:a,tag:u,props:{alt:N,"data-src":"http:\u002F\u002F123.207.79.108\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200513\u002F640.webp",loading:v},children:[]}]},{type:b,value:c},{type:a,tag:g,props:{id:"同步非阻塞ionio"},children:[{type:a,tag:f,props:{href:"#%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9Eionio",ariaHidden:h,tabIndex:i},children:[{type:a,tag:j,props:{className:[k,l]},children:[]}]},{type:b,value:O}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"非阻塞IO，进程发起read操作，内核会立即返回，如果数据还没准备好，会返回一个error。\n进程得到error的结果后，可以去做其他事情，待会再来轮询read操作，再次查询准备结果。\n如果数据准备好了，进程又发起read操作，进程将会被阻塞，直到数据从内核空间写入到用户空间。\n非阻塞IO问题在于绝大部分的轮询调用是无效的，消耗CPU时间。\n"},{type:a,tag:u,props:{alt:O,"data-src":"http:\u002F\u002F123.207.79.108\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200513\u002F641.webp",loading:v},children:[]}]},{type:b,value:c},{type:a,tag:g,props:{id:"多路复用io"},children:[{type:a,tag:f,props:{href:"#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io",ariaHidden:h,tabIndex:i},children:[{type:a,tag:j,props:{className:[k,l]},children:[]}]},{type:b,value:w}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"UNIX\u002FLinux提供了select、poll、epoll系统调用（epoll比poll、select效率高，做的事情是一样的）。\n进程发起select调用，进程会被select调用阻塞，然后内核会监视这个select所负责的NIO的数据准备情况。\n如果有一个数据准备好了，select就会返回。然后进程再去发起read操作，被read操作阻塞，直到数据从内核空间写入到用户空间。\n所以"},{type:a,tag:x,props:{},children:[{type:b,value:"多路复用"}]},{type:b,value:"就是"},{type:a,tag:x,props:{},children:[{type:b,value:"多路"}]},{type:b,value:"NIO"},{type:a,tag:x,props:{},children:[{type:b,value:"复用"}]},{type:b,value:"一个进程进行处理，因此一个进程就能处理多个NIO，提高并发量。\n当连接数不是很高，使用多路复用性能和响应速度可能会被BIO要差。\n虽然多路复用使用的是NIO，但是由于进程在阶段一被select调用阻塞（虽然不是被IO阻塞），阶段二被read操作阻塞，所以对于进程而已，多路复用IO还是BIO。\n"},{type:a,tag:u,props:{alt:w,"data-src":"http:\u002F\u002F123.207.79.108\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200513\u002F642.webp",loading:v},children:[]}]},{type:b,value:c},{type:a,tag:g,props:{id:"异步非阻塞ioaio"},children:[{type:a,tag:f,props:{href:"#%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9Eioaio",ariaHidden:h,tabIndex:i},children:[{type:a,tag:j,props:{className:[k,l]},children:[]}]},{type:b,value:P}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"进程调用aio_read操作，内核空间无论是否已经准备好数据没有，内核都会立即返回，进程就可以去做别的事。\n之后内核会负责将数据缓存到内核空间，然后将数据从内核空间写入到用户空间。\n在阶段一和阶段二完成后，内核才会去通知进程。\n"},{type:a,tag:u,props:{alt:P,"data-src":"http:\u002F\u002F123.207.79.108\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200513\u002F643.webp",loading:v},children:[]}]},{type:b,value:c},{type:a,tag:g,props:{id:Q},children:[{type:a,tag:f,props:{href:"#%E5%85%B3%E4%BA%8E%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E",ariaHidden:h,tabIndex:i},children:[{type:a,tag:j,props:{className:[k,l]},children:[]}]},{type:b,value:Q}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"像js里，有时候虽然调用时异步的，但为了避免层层的callback嵌套，希望能阻塞到完成，这时候需要异步阻塞。"}]},{type:b,value:c},{type:a,tag:g,props:{id:R},children:[{type:a,tag:f,props:{href:"#%E6%80%BB%E7%BB%93",ariaHidden:h,tabIndex:i},children:[{type:a,tag:j,props:{className:[k,l]},children:[]}]},{type:b,value:R}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:a,tag:u,props:{alt:"五种IO模型","data-src":"http:\u002F\u002F123.207.79.108\u002Ffile\u002Ffile\u002Fblog\u002Fcode\u002F20200513\u002F644.webp",loading:v},children:[]}]},{type:b,value:c},{type:a,tag:g,props:{id:S},children:[{type:a,tag:f,props:{href:"#select",ariaHidden:h,tabIndex:i},children:[{type:a,tag:j,props:{className:[k,l]},children:[]}]},{type:b,value:S}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"调用select会把相应socket的fd_set从用户空间拷贝到内核空间，阻塞直到有就绪事件或者超时返回。\n调用返回会把fd_set从内核空间拷贝回用户空间。之后遍历整个fd_set，来找就绪的socket。\nselect几乎在所以平台都支持，但是在linux上限制了单进程fd最大为1024，并且需要通过轮询遍历来查找就绪socket，效率低。"}]},{type:b,value:c},{type:a,tag:g,props:{id:T},children:[{type:a,tag:f,props:{href:"#poll",ariaHidden:h,tabIndex:i},children:[{type:a,tag:j,props:{className:[k,l]},children:[]}]},{type:b,value:T}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"poll基本跟select一样，但是他使用链表保存fd_set，所以没有fd数量限制。\n但是依然存在来回的拷贝和遍历socket问题。"}]},{type:b,value:c},{type:a,tag:g,props:{id:U},children:[{type:a,tag:f,props:{href:"#epoll",ariaHidden:h,tabIndex:i},children:[{type:a,tag:j,props:{className:[k,l]},children:[]}]},{type:b,value:U}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"epoll的fd限制于硬件资源，1G内存机器能打开十万连接。\n只有活跃的socket才会调用回调函数，并且通过内存映射共享内存，减少数据拷贝。\nepoll对fd的操作模式有两种，水平触发（level trigger，LT）和边缘触发（edge trigger，ET）"}]},{type:b,value:c},{type:a,tag:G,props:{},children:[{type:b,value:c},{type:a,tag:m,props:{},children:[{type:b,value:"水平触发：内核会通知某个socket就绪，如果不做任何操作的话，内核还会继续通知"}]},{type:b,value:c},{type:a,tag:m,props:{},children:[{type:b,value:"边缘触发：内核之后通知一次就绪事件，如果不做任何操作的话，内核下次就不再通知了"}]},{type:b,value:c}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"参考文章："}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:a,tag:f,props:{href:"https:\u002F\u002Fwww.jianshu.com\u002Fp\u002Fdfd940e7fca2",rel:[q,r,s],target:t},children:[{type:b,value:"聊聊IO多路复用之select、poll、epoll详解"}]}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:a,tag:f,props:{href:"https:\u002F\u002Fcloud.tencent.com\u002Fdeveloper\u002Farticle\u002F1005481",rel:[q,r,s],target:t},children:[{type:b,value:"大话 Select、Poll、Epoll"}]}]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:a,tag:f,props:{href:"https:\u002F\u002Fwww.jianshu.com\u002Fp\u002F430141f95ddb",rel:[q,r,s],target:t},children:[{type:b,value:"select和epoll区别"}]}]}]},excerpt:{type:B,children:[{type:a,tag:e,props:{},children:[{type:b,value:C},{type:a,tag:f,props:{href:D,rel:[q,r,s],target:t},children:[{type:b,value:E}]},{type:b,value:F}]}]},dir:V,path:"\u002F操作系统\u002F20200513\u002FLinux的IO模型",extension:".md",title:z,url:"\u002Fblog-code\u002Fview\u002F操作系统\u002F20200513\u002FLinux的IO模型",createAt:new Date(1589328000000),updateAt:new Date(1589328000000),attributes:[{name:"createAt",value:W},{name:"updateAt",value:W},{name:"sort",value:V,url:"\u002Fblog-code\u002Fpage\u002F操作系统\u002F20200513\u002F1\u002F"}]}}],fetch:{},mutations:void 0}}("element","text","\n","td","p","a","h1","true",-1,"span","icon","icon-link","li","tr","th","阻塞","nofollow","noopener","noreferrer","_blank","img","lazy","多路复用IO","strong","无名の窝","Linux的IO模型","2020-05-13T00:00:00.000Z","root","本文主要是","https:\u002F\u002Fmp.weixin.qq.com\u002Fs\u002FRkncXcZT4nDQgdLeUcFaxQ","聊聊 Linux 中的五种 IO 模型","的概括。","ul","table","thead","tbody","同步非阻塞IO","异步非阻塞IO","非阻塞,异步等回调","同步阻塞IO（BIO）","同步非阻塞IO（NIO）","异步非阻塞IO（AIO）","关于异步阻塞","总结","select","poll","epoll","\u002F操作系统\u002F20200513","2020-05-13")));