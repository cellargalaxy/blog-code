# 缓存作用
+ 高性能：查询速度快
+ 高并发：支持并发高

# Redis模型
1. 先注册server socket的可读事件。
2. 当有客户端请求接入，IO多路复用就会把server socket放进队列里。
3. 然后事件分派器会把server socket分派到应答处理器里，获得与客户端连接的socket，将socket的可读事件与命令请求处理器关联。
4. 当客户端发出命令请求，socket有可读事件，事件分派器就会把socket分派到命令请求处理器。
5. 执行命令完成后，会把socket的可写事件与命令回复处理器关联。
6. 等到客户端可写，有可写事件，又会把socket放进队列里，分派到命令回复处理器回复命令执行结果。

+ 使用纯内存，速度快
+ 使用IO多路复用
+ Redis单线程，避免上写文切换

# Redis数据类型
+ string
+ hash：一个用户有多设备
+ list：分页
+ set：做交并差集
+ sorted set：粉丝排序

# Redis过期策略
+ 定期删除：每隔一段时间随机抽一些key看看过期了没，过期了清掉
+ 惰性删除：当某个key被查询到，先检查这个key过期了没，过期了清掉，返回空
+ 定时删除：每个key设置一个定时器，时间到了就删除此key

定期删除+惰性删除，但是会导致大量过期key积累，耗尽内存

# 缓存淘汰算法（LRU）
+ noeviction: 写入新数据就报错
+ allkeys-lru：删除最少使用key（最常使用，可以简单用LinkedHashMap实现）
+ allkeys-random：删除随机key
+ volatile-lru：删除有过期时间的最少使用key
+ volatile-random：删除有过期时间的随机key
+ volatile-ttl：删除最快过期的key

# Redis主从架构
对于缓存一般都是支持读高并发，所以使用一主多从，写在主节点，读在从节点。主节点必须开启持久化。
+ 当从节点初次连接到主节点，会触发一次全量复制。
+ 主节点会起一个线程生产一个RDB快照，同时将接受到的写命令缓存到内存里。
+ 主节点会把RDB快照发给从节点，从节点会把RDB文件保存到硬盘里
+ 从节点会清空自己的数据，加载RDB数据到内存里。期间以旧数据对外提供服务
+ 如果因为RDB文件过大等原因，导致复制时间超时(默认60s)会认为复制失败
+ 主节点会把内存里缓存的写命令发给从节点

+ 主节点会在内存里维护一个backlog，以及主从节点都会保存一个replica offset
+ 如果主从网络断开，恢复时会从上次的replica offset里继续复制数据
+ 如果找不到对应的replica offset，则会触发一次全量复制

# Redis哨兵集群
+ 集群监控：负责监控集群的主从节点是否正常
+ 消息通知：如有节点挂了，负责消息警告
+ 故障转移：如果主节点挂了，会转移到从节点上
+ 配置中心：故障转移后告知客户端新的主节点地址

+ 哨兵节点至少三个或以上（两个哨兵节点两个节点共同决策，如故障转移。所以最少要三个节点，保证哨兵集群的高可用）
+ 需要半数或以上哨兵节点认为主节点主观宕机，才构成客观宕机，运行进行故障转移

## 哨兵集群的数据丢失
+ 故障转移后，从节点没完整复制数据
+ 主节点脱离了正常网络但还运行着，故障转移后就有两个主节点。
  客户端可能还没来得及切换主节点，导致往旧主节点写数据。
  当旧主节点网络恢复加入集群成为从节点，就会被清空数据

可以配置使主节点至少跟一个从节点的数据同步少于10s，大于就拒绝写操作

# Redis持久化
## RDB
+ 子进程每隔五分钟或者更长时间生成一次，对性能影响小，丢的数据比较多，适合做冷备份
+ 如果数据量大，在生成RDB文件的时候可能会导致服务停顿数毫秒/秒
+ 重启恢复速度比AOP快
## AOF
+ 子进程每隔1秒做一次追加写入，最多丢1s的数据，追加写入性能高
+ 当AOF文件过大，进行重写压缩的时候会生成新的文件，旧的文件照常写入

一般是RDB和AOF两种都同时开启，这样既能RDB的快速恢复，也有AOF的少丢数据

# 缓存雪崩
由于缓存被删除/过期/宕机导致请求都到了数据库里
+ 事前：高可用，主从哨兵或者Redis集群
+ 事中：使用本地缓存、服务限流降级，避免数据库被打死
+ 事后：使用RDB/AOF重启恢复redis数据

# 缓存穿透
编造大量不正常数据，无缓存，导致都打到数据库
+ 检查数据合法性
+ 将这些数据也缓存到Redis里

# 缓存击穿
热点数据过期，大量请求打到数据库
+ 基本不跟新，考虑将数据设置为不过期
+ 用Redis锁进行更新
+ 起一个定时任务主动更新

# 缓存与数据库的一致性
先更新数据库再删除缓存，缓存lazy生成

[如何保证缓存与数据库双写一致性？](https://doocs.github.io/advanced-java/#/./docs/high-concurrency/redis-consistence)里说的：

> 先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。
> 解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。
> 因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。

我觉得是无稽之谈，缓存数据不是一般都有过期时间吗，过期兜底不就好了吗？
为什么redis删数据失败，读数据还能成功？这时候是不是应该考虑一下是不是redis挂了？
先删了缓存，还没改数据库的数据又被其他请求查回缓存里了，不也一样导致不一致吗？